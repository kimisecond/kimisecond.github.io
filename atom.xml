<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kimi&#39;s Blog</title>
  
  <subtitle>一个垃圾分类站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.kimisecond.com/"/>
  <updated>2018-03-15T16:57:48.940Z</updated>
  <id>https://blog.kimisecond.com/</id>
  
  <author>
    <name>Kimisecond</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库概念 序言/Introduction 第一课笔记</title>
    <link href="https://blog.kimisecond.com/2018/03/DBS-Concept-Lecture-One/"/>
    <id>https://blog.kimisecond.com/2018/03/DBS-Concept-Lecture-One/</id>
    <published>2018-03-15T16:43:34.000Z</published>
    <updated>2018-03-15T16:57:48.940Z</updated>
    
    <content type="html"><![CDATA[<p>2018年3月1日<br>12:59</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。<br>如有错误，请在评论中或直接联系我指正，谢谢！<br><a id="more"></a></p><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2jRPm10AeVJmsROgt" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/u/s!AkFCnbJhobZ2jRPm10AeVJmsROgt" target="_blank" rel="noopener">(pdf)</a></strong></p><table><thead><tr><th>Database management system (DBMS)</th><th>Contains information  about a particular enterprise</th></tr></thead><tbody><tr><td></td><td>Collection of interrelated data</td></tr><tr><td></td><td>Set of programs to <em>access</em> the data（增删改查）</td></tr><tr><td></td><td>An environment that is both <strong>convenient and efficient</strong> to use</td></tr></tbody></table><p>教材：University Database Example 第六版</p><h2 id="Drawbacks-of-using-file-systems-to-store-data"><a href="#Drawbacks-of-using-file-systems-to-store-data" class="headerlink" title="Drawbacks of using file systems to store data"></a>Drawbacks of using file systems to store data</h2><ul><li>Data redundancy and inconsistency一致性<ul><li>Multiple file formats, duplications of information in different files</li></ul></li><li>Difficulty in accessing data<ul><li>Need to write a new program to carry out each new task</li></ul></li><li>Data isolation - multiple files and formats</li><li>Integrity problems 数据完整性<ul><li>Integrity constraints (e.g., grade > 0) become “buried” in program code<br>rather than being stated explicitly 数据合法性等问题</li><li>Hard to add new constraints or change existing ones</li></ul></li><li>Atomicity of update 修改原子性<ul><li>Failures may leave database in an inconsistent state with partial<br>updates carried out</li><li>e.g.: Transfer of funds from one account to another should either<br>complete or not happen at all</li><li>Rollback 回滚</li></ul></li><li>Concurrent access by multiple users 并发访问<ul><li>Concurrent access needed for performance</li><li>Uncontrolled concurrent accesses can lead to inconsistencies</li><li>锁机制</li></ul></li><li>Security problems<ul><li>Hard to provide user access to some, but not all, data</li></ul></li></ul><h2 id="View-of-Data-数据的视图"><a href="#View-of-Data-数据的视图" class="headerlink" title="View of Data 数据的视图"></a>View of Data 数据的视图</h2><p>A major purpose of a database system is to provide uses with an <em>abstract</em> view<br>of a data. The database system hides certain details of how the data are stored<br>and maintained. P6<br><img src="/2018/03/DBS-Concept-Lecture-One/4afda9b1ff307f1d243f2bfdafc65ce1.png" alt="view I Figure 1.1 view level view 2 logical I-ewe I physical levee I view n The three levels Of data abstraction. "></p><h3 id="Physical-level"><a href="#Physical-level" class="headerlink" title="Physical level"></a>Physical level</h3><p>The lowest level of abstraction describes how the data are actually stored. The<br>physical level describes complex low-level data structures in detail.</p><h3 id="Logical-level"><a href="#Logical-level" class="headerlink" title="Logical level"></a>Logical level</h3><p>The next-higher level of abstraction describes what data are stored in the<br>database, and what relationships exist among those data.</p><h3 id="View-level"><a href="#View-level" class="headerlink" title="View level"></a>View level</h3><p>The highest level of abstraction describes only part of the entire database.<br>(Application programs)</p><h2 id="Instances-and-Schemas"><a href="#Instances-and-Schemas" class="headerlink" title="Instances and Schemas"></a>Instances and Schemas</h2><p>Similar to types and variables in programming languages</p><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>模式，指的是数据库的结构（表格式）</p><ul><li>Physical schema: database design at the physical level</li><li>Logical schema: logical level<h3 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h3>实例<br>给定schema，在当前数据库中的数据<br>The actual content of the database at a particular point in time</li><li>Analogous to the value of a variable<h3 id="Physical-Data-Independence"><a href="#Physical-Data-Independence" class="headerlink" title="Physical Data Independence"></a>Physical Data Independence</h3>物理数据独立性<br>The ability to modify the physical schema without changing the logical schema</li><li><strong>Applications depend on the logical schema</strong></li><li>In general, the interfaces between the various levels and components should<br>be well defined so that changes in some parts do not seriously influence<br>others</li></ul><h2 id="Data-Models"><a href="#Data-Models" class="headerlink" title="Data Models"></a>Data Models</h2><p>A way to describe the design of a database at the physical, logical and view<br>level.</p><ul><li>A collection of tools for describing<ul><li>Data</li><li>Data relationships</li><li>Data semantics</li><li>Data constraints</li></ul></li><li><strong>Relational model关系模型</strong></li><li>Entity-Relationship data model (mainly for database design)<br>(E-R)实体联系模型</li><li>Object-based data models (Object-oriented and Object-relational)</li><li>Semi-structured data model (XML) 半结构化数据模型 json *自学</li><li>Other older models<ul><li>Network model</li><li>Hierarchical model （银行）</li></ul></li></ul><p>NoSQL 数据库数据模型</p><ul><li>Key-Value</li><li>Document-oriented</li><li>Graph</li><li>Column-family 列族</li></ul><h2 id="Database-Language"><a href="#Database-Language" class="headerlink" title="Database Language"></a>Database Language</h2><ul><li>DDL data definition language: specify the database schema</li><li>DML data manipulation language: express database queries and update</li><li>They are not two separate languages, instead they are parts of a single<br>database language, such as SQL</li></ul><h2 id="Relational-Model"><a href="#Relational-Model" class="headerlink" title="Relational Model"></a>Relational Model</h2><p>Example of tabular data in the relational model<br><img src="/2018/03/DBS-Concept-Lecture-One/4f21f714cea913a9528efd27d7b43acb.png" alt="22222 12121 32343 45565 98345 76766 10101 58583 83821 15151 33456 76543 Einstein wu El Said Katz Kim Crick Sri n i vasan Califieri Brandt Mozart Gold Sin dep f Physics Finance History Comp. Sci. Elec. Eng. Biology Comp. Sci. History Comp. Sci. Music Physics Finance salary 75000 80000 72000 65000 62000 92000 87000 (a) The instructor table "><br>关系表<br>列：属性 首行决定schema 下面即为instance</p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>增删改查<br>两种类</p><ul><li>Procedural DMLs require a user to specify what data are needed and how to<br>get those data</li><li>Declarative DMLs (also referred to as nonprocedural DMLs) require a user to<br>specify what data are needed without specifying how to get those data<br>Query language<br>SQL is the best.</li></ul><p>e.g.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept <span class="keyword">name</span> = ’History’;</span><br></pre></td></tr></table></figure></p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><ul><li>Data storage and definition language define the implementation details of<br>the database schemas(hidden from the users)</li><li>Must satisfy certain consistency constraints<ul><li>Domain constraints</li><li>Referential integrity</li><li>Assertions</li><li>Authorization</li></ul></li></ul><p>SQL provides a rich DDL that allows one to define tables, integrity constraints,<br>assertions, etc.<br>e.g.:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department</span><br><span class="line">(dept_name <span class="built_in">char</span> (<span class="number">20</span>),</span><br><span class="line">building <span class="built_in">char</span> (<span class="number">15</span>),</span><br><span class="line">budget <span class="built_in">numeric</span> (<span class="number">12</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p><p>Application programs generally access databases through one of</p><ul><li>Embedded/ language extension</li></ul><h2 id="Database-design"><a href="#Database-design" class="headerlink" title="Database design"></a>Database design</h2><p>The process of designing the general structure of the database</p><ul><li>Logical Design - Deciding on the database schema<ul><li>Business decision</li><li>CS decision</li></ul></li><li>Physical Design - Deciding on the physical layout of the database</li></ul><h2 id="Design-approaches"><a href="#Design-approaches" class="headerlink" title="Design approaches"></a>Design approaches</h2><p>Normalization theory C8</p><ul><li>Formalize what designs are bad, and test for them<br>E-R Model C7 (*Test)</li></ul><h2 id="The-Entity-Relationship-Model"><a href="#The-Entity-Relationship-Model" class="headerlink" title="The Entity-Relationship Model"></a>The Entity-Relationship Model</h2><p>Models an enterprise as a collection of entities and relationships</p><ul><li>Described by a set of attributes<br>Represented diagrammatically by an entity-relationship diagram<br><img src="/2018/03/DBS-Concept-Lecture-One/58eeb82b64bd679f7cba00001e112942.png" alt="instructor ID salary department dept name building Figure 1.3 A sample E -R diagram. "></li><li>Entity sets are represented by a rectangular box with the entity set name in<br>the header and the attributes listed below it.</li><li>Relationship sets are represented by a diamond connecting a pair of related<br>entity sets. The name of the relationship is placed inside the diamond.</li></ul><h2 id="Storage-Management-Physical-Level"><a href="#Storage-Management-Physical-Level" class="headerlink" title="Storage Management (Physical Level)"></a>Storage Management (Physical Level)</h2><p>The storage manager is the component of a database system that provides the<br>interface between the low-level data stored in the database and the application<br>programs and queries submitted to the system.</p><h2 id="Query-Processing"><a href="#Query-Processing" class="headerlink" title="Query Processing"></a>Query Processing</h2><ol><li>Parsing and translation</li><li>Optimization</li><li>Evaluation</li></ol><h2 id="Transaction-An-Execution-of-a-DB-Program"><a href="#Transaction-An-Execution-of-a-DB-Program" class="headerlink" title="Transaction: An Execution of a DB Program"></a>Transaction: An Execution of a DB Program</h2><ul><li>A transaction is a collection of operations that performs a single logical<br>function in a database application<ul><li>An atomic sequence of database actions (R/W)</li><li>Each transaction, executed completely, must leave the DB in a consistent<br>state if DB is consistent</li></ul></li><li>Recovery manager, failure recovery</li><li>Concurrency-control manager</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年3月1日&lt;br&gt;12:59&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;br&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="Database_System_Concept" scheme="https://blog.kimisecond.com/tags/Database-System-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 安全/Security 第十四章笔记</title>
    <link href="https://blog.kimisecond.com/2018/01/OS-Concept-Chapter-Fourteen/"/>
    <id>https://blog.kimisecond.com/2018/01/OS-Concept-Chapter-Fourteen/</id>
    <published>2018-01-03T22:59:35.000Z</published>
    <updated>2018-03-15T11:56:17.298Z</updated>
    
    <content type="html"><![CDATA[<p>2018年1月4日<br>08:06</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i3W99nWFc24klotd" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i3bSDwr7L7eDUjRA" target="_blank" rel="noopener">(pdf)</a></strong></p><ol><li><p>Safety</p></li><li><p>Security</p></li></ol><p>包含十四、十五章</p><h2 id="系统安全的基本概念"><a href="#系统安全的基本概念" class="headerlink" title="系统安全的基本概念"></a>系统安全的基本概念</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>数据机密性</p><ul><li>将几米的数据置于保密状态，仅允许被授权的用户访问计算机系统中的信息</li></ul><p>数据完整性</p><ul><li>指未经授权的用户不能擅自修改系统中所保存的信息,且能保持系统中的数据一致性。(建立、删除、增加、修改)</li></ul><p>系统可用性</p><ul><li>指授权用户的正常请求能及时、正确、安全地得到服务或相应</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>多面性——在较大规模的系统中都存在着多个风险点：<strong>物理安全、逻辑安全、安全管理</strong>三方面的内容</p><p>动态性——信息的有效性、攻击手段不断变化</p><p>层次性——涉及诸多方面、且相当复杂的问题，因此需要采用系统工程的方法来解决，通常也采用层次化方法</p><p>适度性——根据实际需要，提供适度的安全目标加以实现，全面覆盖难于实现</p><h3 id="安全威胁的类型"><a href="#安全威胁的类型" class="headerlink" title="安全威胁的类型"></a>安全威胁的类型</h3><h4 id="假冒-Masquerading-用户身份"><a href="#假冒-Masquerading-用户身份" class="headerlink" title="假冒(Masquerading)用户身份"></a><em>假冒(Masquerading)用户身份</em></h4><ul><li><p>也称为<strong>身份攻击</strong></p></li><li><p>指用户身份被非法窃取，亦即攻击者伪装成一个合法用户，利用安全体制所允许的操作去破坏系统安全</p></li><li><p>在网络环境下，假冒者又可分为发方假冒的收方假冒两种</p></li><li><p>用户在进行通信或交易之前，必须对发方和收方的身份进行<strong>认证</strong></p></li></ul><h4 id="数据截取-Data-Interception"><a href="#数据截取-Data-Interception" class="headerlink" title="数据截取(Data Interception)"></a><em>数据截取(Data Interception)</em></h4><ul><li><p>未经核准通过非正当途径截取网络中的文件和数据，由此造成网络信息的泄漏</p></li><li><p>街区方式可以是直接中电话线上窃听，也可以是利用计算机和相应的软件来截取信息</p></li></ul><h4 id="拒绝服务-Denial-of-Server-DOS"><a href="#拒绝服务-Denial-of-Server-DOS" class="headerlink" title="拒绝服务(Denial of Server DOS)"></a><em>拒绝服务(Denial of Server DOS)</em></h4><ul><li>未经主管部门的许可，而拒绝接收一些用户对网络中的资源进行访问</li></ul><h4 id="修改-Modification-信息"><a href="#修改-Modification-信息" class="headerlink" title="修改(Modification)信息"></a><em>修改(Modification)信息</em></h4><ul><li>未经核准的用户不仅可能从系统中截获信息，而且还可以修改数据包中的信息，比如，可以修改数据包中的协议控制信息，使该数据包被传送到非指定的目标。</li></ul><h4 id="伪造-Fabrication-信息"><a href="#伪造-Fabrication-信息" class="headerlink" title="伪造(Fabrication)信息"></a><em>伪造(Fabrication)信息</em></h4><ul><li>将编造的虚假信息送入计算机，或者在某些文件中增加一些虚假的记录，这同样会威胁到系统中数据的完整性</li></ul><h4 id="否认-Repudiation-操作"><a href="#否认-Repudiation-操作" class="headerlink" title="否认(Repudiation)操作"></a><em>否认(Repudiation)操作</em></h4><ul><li>又称为抵赖，是指某人不承认自己曾经做过的事情。（在发出一条消息后又否认这条消息）</li></ul><h4 id="中断-Interruption-传输"><a href="#中断-Interruption-传输" class="headerlink" title="中断(Interruption)传输"></a><em>中断(Interruption)传输</em></h4><ul><li><p>指系统中因某资源被破坏而造成信息传输的中断</p></li><li><p>中断可能由硬件故障引起，如磁盘故障、电源掉电和通信线路断开等；也可能由软件故障引起</p></li></ul><h4 id="通信量分析-Traffic-Analysis"><a href="#通信量分析-Traffic-Analysis" class="headerlink" title="通信量分析(Traffic Analysis)"></a><em>通信量分析(Traffic Analysis)</em></h4><ul><li><p>通过窃听手段窃取在线路中传输的信息，再考察数据包中的协议控制信息，可以了解到通信者的身份、地址；</p></li><li><p>通过研究数据包的长度和通信频度，攻击者可以了解到所交换数据的性质</p></li></ul><p>##数据加密技术</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><blockquote><p>  经典密码学</p><p>  1949年，信息论的创始人香农 (C.E. Shannon) 提出了数据加密的必要性</p></blockquote><h3 id="模型组成"><a href="#模型组成" class="headerlink" title="模型组成"></a>模型组成</h3><p>四部分：</p><ul><li><p><strong>明文(plain text)</strong>——准备加密的文本，明文P</p></li><li><p><strong>密文(cipher text)</strong>——加密后的文本，密文Y</p></li><li><p><strong>加密（解密）算法E(D)</strong>——用于实现从明文（密文）到密文（明文）转换的公式、规则或程序</p></li><li><p><strong>密钥K</strong>——密钥是加密和解密算法中的关键参数</p></li></ul><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/a33b2c65065aa7cd9dff7ef956d54a21.png" alt="明 文 p Y 算 法 加 密 钥 匙 Ke 解 密 Y 算 法 DKcl 明 文 p 解 密 钥 匙 Rd"></p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对称性分类</p><ul><li><p>对称加密算法</p></li><li><p>非对称加密算法</p></li></ul><p>所变换铭文的单位分类</p><ul><li><p>序列加密算法</p></li><li><p>分组加密算法</p></li></ul><h3 id="对称加密算法与非对称加密算法"><a href="#对称加密算法与非对称加密算法" class="headerlink" title="对称加密算法与非对称加密算法"></a>对称加密算法与非对称加密算法</h3><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a><em>对称加密算法</em></h4><ul><li><p>DES(Data Encryption Standard) (IBM 1971-1972)</p></li><li><p>加密和解密使用的密钥相同</p></li></ul><h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a><em>非对称加密算法</em></h4><ul><li><p>对数据进行加密和解密时，使用不同的密钥（公私钥）。每个用户都保存一对密钥，公钥对外公开。</p></li><li><p>发信者公钥加密，收信者私钥解密</p></li></ul><h3 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h3><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><em>数字签名</em></h4><blockquote><p>  在利用计算机网络传送报文时，可将公钥用于电子（数字）签名，来代替传统的签名。而为了能使数字签名能够代替传统签名，必须满足以下三个条件：</p></blockquote><ol><li><p>接收者能够核实发送者对报文的签名</p></li><li><p>发送者事后不能抵赖其对报文的签名</p></li><li><p>接收者无法伪造对报文的签名</p></li></ol><h5 id="简单数字签名"><a href="#简单数字签名" class="headerlink" title="简单数字签名"></a>简单数字签名</h5><ul><li><p>发送者A可使用私用密钥对明文P进行加密，传送给接收者B。B可利用A的公开密钥进行解密</p></li><li><p>接收者能利用A的公开密钥进行解密，这便证实了发送者对报文的签名</p></li></ul><h5 id="保密数字签名"><a href="#保密数字签名" class="headerlink" title="保密数字签名"></a>保密数字签名</h5><ul><li>为了实现在发送者A和接收者B之间的保密数字签名，要求A和B都具有密钥</li></ul><h4 id="数字证书-Certificate"><a href="#数字证书-Certificate" class="headerlink" title="数字证书(Certificate)"></a><em>数字证书(Certificate)</em></h4><ul><li><p>虽然可以利用公钥发进行数字签名，但事实上又无法证明公钥的持有者是合法的持有者</p></li><li><p>必须要一个可信的认证机构CA (Certification Authority).<br>由该机构为公钥发放一份公钥证书，又把该公钥证书称为数字证书，用于证明通信请求者的身份</p></li></ul><h3 id="网络加密技术"><a href="#网络加密技术" class="headerlink" title="网络加密技术"></a>网络加密技术</h3><ul><li><p><strong>链路加密</strong>——对在网络相邻节点之间通信线路上传输的数据进行加密</p></li><li><p><strong>端-端加密</strong></p><ul><li><p>在源主机或前端机FEP中的高层（从传输层到应用层）对所传输的数据进行加密</p></li><li><p>在物理信道上和中间节点中，报文的正文始终是密文，直至信息到达目标主机才被翻译</p></li></ul></li></ul><h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><h3 id="基于口令的身份认证"><a href="#基于口令的身份认证" class="headerlink" title="基于口令的身份认证"></a>基于口令的身份认证</h3><ul><li><p>当一个用户要登陆某台计算机时，操作系统通常都要认证用户的身份</p></li><li><p>利用口令来确认认证用户的身份</p></li></ul><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a><em>基本要求</em></h4><ul><li><p>长度适中</p><ul><li><p>通常的口令是由一串字母和数字组成。如果口令太短，则很容易被攻击者猜中。</p></li><li><p>如果使用较长的口令，可以显著地增加猜中一个口令的时间</p></li></ul></li><li><p>自动断开连接</p><ul><li><p>为了给攻击者猜中口令增加难度，在口令机制中引入自动断开连接的功能，即只允许用户输入有限次数地不正确口令</p></li><li><p>如果不正确次数超过一定量，系统则自动断开此连接</p></li></ul></li><li><p>隐蔽回送显示</p><ul><li>在用户输入口令时，登陆程序不应将该口令回送到屏幕上显示</li></ul></li><li><p>记录和报告</p><ul><li><p>记录所有用户登陆进入系统和退出系统的时间</p></li><li><p>也用来记录和报告攻击者非法猜测口令的企图，以及所发生地于安全性有关的其他不轨行为，这样便能及时发现有人在对系统的安全性进行攻击</p></li></ul></li></ul><h4 id="一次性口令"><a href="#一次性口令" class="headerlink" title="一次性口令"></a><em>一次性口令</em></h4><ul><li>为了把由于口令泄露所造成的损失减到最小，用户应当经常改变口令</li></ul><h4 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a><em>口令文件</em></h4><ul><li><p>配置有一份口令文件，用于保存合法用户的口令和与口令相联系的特权</p></li><li><p>经常利用加密技术，选择一个函数来对口令进行加密</p></li></ul><p>尽量对口令进行加密是一个很好的方法，但它也不是绝对的安全可靠。其主要威胁来自于两个方面：</p><ol><li><p>当攻击者已掌握了口令的解密密钥时，就可用它来破译口令</p></li><li><p>利用加密程序来破译口令，如果运行加密程序的计算机速度足够快，则通常只要几个小时便可破译口令</p></li></ol><p>因此，口令文件需要妥善保管。</p><h3 id="基于物理标志的认证技术"><a href="#基于物理标志的认证技术" class="headerlink" title="基于物理标志的认证技术"></a>基于物理标志的认证技术</h3><h4 id="基于磁卡的认证技术"><a href="#基于磁卡的认证技术" class="headerlink" title="基于磁卡的认证技术"></a><em>基于磁卡的认证技术</em></h4><ul><li><p>在磁条中存储用户信息</p></li><li><p>通常在磁卡认证的基础上，<strong>增加口令机制</strong></p></li></ul><h4 id="基于IC卡的认证技术"><a href="#基于IC卡的认证技术" class="headerlink" title="基于IC卡的认证技术"></a><em>基于IC卡的认证技术</em></h4><ul><li><p>IC卡是集成电路卡的英文缩写</p></li><li><p>IC卡中可装入CPU和存储器芯片，使该卡具有一定的智能</p></li></ul><h3 id="基于生物标志的认证技术"><a href="#基于生物标志的认证技术" class="headerlink" title="基于生物标志的认证技术"></a>基于生物标志的认证技术</h3><h4 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a><em>指纹</em></h4><h4 id="视网膜"><a href="#视网膜" class="headerlink" title="视网膜"></a><em>视网膜</em></h4><ul><li><p>眼纹</p></li><li><p>信息量远比指纹复杂，信息需要256个字节编码</p></li></ul><h4 id="声音"><a href="#声音" class="headerlink" title="声音"></a><em>声音</em></h4><ul><li><p>即使在强干扰的环境下，也能很好地分辨出每个人的语音</p></li><li><p><strong>基本方法：对一个人说好的语音进行分析，利用声音特征制作成语音口令系统</strong></p></li></ul><h4 id="手指长度"><a href="#手指长度" class="headerlink" title="手指长度"></a><em>手指长度</em></h4><h3 id="基于公钥的认证技术"><a href="#基于公钥的认证技术" class="headerlink" title="基于公钥的认证技术"></a>基于公钥的认证技术</h3><h2 id="访问控制技术"><a href="#访问控制技术" class="headerlink" title="访问控制技术"></a>访问控制技术</h2><h3 id="访问权"><a href="#访问权" class="headerlink" title="访问权"></a>访问权</h3><ul><li><p>为了对系统中的对象加以保护，应由系统来控制进程对对象的访问</p></li><li><p>把一个进程能<strong>对某对象执行操作的权力称为访问权</strong> (Assess<br>Right)。每个访问权可以用一个有序对（对象名，权集）表示，例如，某进程有对文件F1执行读和写操作的权力，这时，可将该进程的访问权表示成(F1,{R/W})。</p></li></ul><h3 id="保护域"><a href="#保护域" class="headerlink" title="保护域"></a>保护域</h3><ul><li><p>为了对系统中的资源进行保护而引入了保护域的概念，保护域简称为“域”。</p></li><li><p>“域”是进程对一组对象访问权的集合，进程只能在指定域内执行操作，这样，“域”也就规定了进程所能访问的对象和能执行的操作。</p></li><li><p>例如：两个域中运行的进程都能使用打印机</p></li><li><p>对象Printer 1同时出现在域2和域3中</p></li></ul><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/83093d5f0463b43bf31405ae46f1fb48.png" alt=""></p><h3 id="进程和域间的联系方式"><a href="#进程和域间的联系方式" class="headerlink" title="进程和域间的联系方式"></a>进程和域间的联系方式</h3><h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a><em>静态</em></h4><ul><li><p>在进程和域之间，可以一一对应，即一个进程只联系着一个域</p></li><li><p>在进程的整个生命期中，其可用资源是固定的，我们把这种域称为“静态域”</p></li></ul><h4 id="动态"><a href="#动态" class="headerlink" title="动态"></a><em>动态</em></h4><ul><li><p>进程和域之间，可以是<strong>一对多的关系，一个进程可以对应多个域</strong></p></li><li><p>在此情况下，可将进程的运行分为若干个阶段，其每个阶段联系着一个域，这样便可根据运行的实际需要，来搞定在进程运行的每个阶段中所能访问的对象</p></li><li><p>把这种一对多的联系方式称为动态联系方式，在采用这种方式的系统中，应增设保护域切换功能，以使进程能在不同的运行阶段，中一个保护域切换到另一个保护域</p></li></ul><h3 id="访问矩阵"><a href="#访问矩阵" class="headerlink" title="访问矩阵"></a>访问矩阵</h3><ul><li><p>可以利用一个矩阵来描述系统的访问控制，并把该矩阵称为访问矩阵 (Access Matrix)</p></li><li><p>访问矩阵中的行代表域，列代表对象，矩阵中的每一项是由一组访问权组成的</p></li><li><p>因为对象已由列显式地定义，故可以只写出访问权而不必写出是哪个对象的访问权，每一项访问权定义了在域Di中执行的进程能对对象Qj所施加的操作集。</p></li><li><p>访问矩阵中的访问权，通常是由资源的拥有着或者管理者所决定的</p></li><li><p>当用户创建一个新文件时，创建者便是拥有者，系统在访问矩阵中为新文件增加一列，由用户决定在该列地某个项中应具有哪些访问权</p></li><li><p>当用户删除此文件时，系统也要相应地在访问矩阵中将该文件对应的列撤销</p></li></ul><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/c99a471f5bfd1f13cc3b9a24948f9cf9.png" alt="F 打 印 机 戔 仪 R R.W-E R.W &amp; W: E W 由 3 个 域 和 8 个 对 象 所 组 成 的 访 问 矩 阵 ．"></p><h2 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h2><h3 id="计算机病毒的定义"><a href="#计算机病毒的定义" class="headerlink" title="计算机病毒的定义"></a>计算机病毒的定义</h3><ul><li><p>计算机病毒是一段程序，它能不断地进行复制和感染其它的程序，无需人为介入便能够由被感染的程序和系统传播出去</p></li><li><p>一般地病毒并不长。对于用C语言编写的病毒程序，通常不超过一页，经编译后小于2KB；用汇编语言编写的病毒程序则更小，可以小到只有几十到几百个字节</p></li></ul><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li><p>占用系统空间</p></li><li><p>占用处理机时间</p></li><li><p>对文件造成破坏</p></li><li><p>使机器运行异常</p></li></ul><h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><ul><li><p>显示自己的能力</p></li><li><p>恶意报复</p></li><li><p>恶意攻击</p></li><li><p>出错程序</p></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>寄生性</p></li><li><p>传染性</p></li><li><p>隐蔽性</p></li><li><p>破坏性</p></li></ul><h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><ul><li><p>文件型病毒：主动攻击型感染和执行时感染</p></li><li><p>内存驻留病毒</p></li><li><p>引导扇区病毒</p></li><li><p>宏病毒</p></li><li><p>电子邮件病毒</p></li></ul><h3 id="隐藏方式"><a href="#隐藏方式" class="headerlink" title="隐藏方式"></a>隐藏方式</h3><ul><li><p><strong>伪装</strong>：利用文件长度发生改变来发现病毒。设计者为了隐藏病毒，通过有所技术，使感染上病毒的文件的长度与原有文件的长度一致</p></li><li><p><strong>隐藏</strong>：病毒程序的设计者常把病毒隐藏在一个不易检查到的地方</p></li><li><p><strong>多形态</strong></p></li></ul><h2 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h2><p>用于实现防火墙功能的技术可分为两类</p><ul><li><p><strong>包过滤技术</strong>：基于该技术所构建的防火墙简单、价廉</p></li><li><p><strong>代理服务技术</strong>：基于该技术所构建的防火墙安全可靠</p></li></ul><p>两者之间有很强的互补性，因而经常同时采用这两种防火墙技术来保障网络安全</p><h3 id="包过滤技术"><a href="#包过滤技术" class="headerlink" title="包过滤技术"></a>包过滤技术</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><em>基本原理</em></h4><ul><li><p>置于Intranet的适当位置，通常在路由器和服务器中</p></li><li><p>对进出Intranet的所有数据包按照指定的过滤规则进行检查，仅对符合指定规则的数据包才准予通行，否则将之抛弃。</p></li></ul><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/e88be756a929a1cccd3f654e818e52e4.png" alt="服 务 器 以 太 网 Intranet 伊 包 过 滤 伊 数 据 包 Internet 至 hternet"></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><em>优缺点</em></h4><ul><li><p>有效灵活</p></li><li><p>简单易行</p></li><li><p>不能防止假冒</p></li><li><p>只在网络层和传输层实现</p></li><li><p>缺乏可审核性</p></li><li><p>不能防止来自内部人员造成的威胁</p></li></ul><h3 id="代理服务技术"><a href="#代理服务技术" class="headerlink" title="代理服务技术"></a>代理服务技术</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a><em>基本原理</em></h4><p>设置一个代理服务器，并将外部网(Internet)与内部网之间的连接分为两段</p><ul><li><p>一段是从Internet上的主机引到代理服务器</p></li><li><p>另一段是由代理服务器连到内部网中的某一个主机（服务器）</p></li></ul><p>每当主机请求时，总被送到代理服务器，并在其中通过安全检查后，再由代理服务器与内部网中的应用服务器建立连接</p><p>所有的Internet上的主机对内部网中应用服务器的访问，都被送到代理服务器，由后者去代替在Internet上的相应主机，对Intranet的应用服务器进行访问</p><p>Internet主机对Intranet应用服务器的访问，<strong>置于代理服务器的安全控制之下</strong>，使其无法了解到Intranet的结构和运行情况</p><h4 id="应用层网关的类型"><a href="#应用层网关的类型" class="headerlink" title="应用层网关的类型"></a><em>应用层网关的类型</em></h4><p>代理服务技术时利用一个应用层网关作为代理服务器的</p><p>应用层网关可分为三种类型：</p><ul><li><p>双穴主机网关</p></li><li><p>屏蔽主机网关</p></li><li><p>屏蔽子网网关</p></li></ul><p>三种都要有一台主机，通常称为“桥头堡主机”(Bastion Host),<br>它起着防火墙的作用，也起着Internet与Intranet之间的隔离作用</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><em>优缺点</em></h4><ul><li><p>屏蔽被保护网</p></li><li><p>对数据流的监控</p></li><li><p>实现复杂</p></li><li><p>需要特定的硬件支持</p></li><li><p>增加服务延迟</p></li></ul><h3 id="规则检查防火墙"><a href="#规则检查防火墙" class="headerlink" title="规则检查防火墙"></a>规则检查防火墙</h3><ul><li><p>集<strong>包过滤防火墙</strong>和<strong>应用级网关</strong>这两种防火墙技术的优点</p></li><li><p>包过滤防火墙：在网络层上通过检查IP地址等手段，过滤掉对Intranet进行访问的非法数据包</p></li><li><p>应用级网关：对服务的类型和服务信息的内容进行检查，过滤掉其中的非法访问</p></li><li><p><strong>性能更好</strong>。为进一步提高性能，增加了用于保障网络安全的新功能</p></li></ul><h4 id="增加三种认证方法"><a href="#增加三种认证方法" class="headerlink" title="增加三种认证方法"></a><em>增加三种认证方法</em></h4><ul><li><p><strong>用户认证</strong>——用于对用户的访问权限进行认证</p></li><li><p><strong>客户认证</strong>——对用户客户机IP地址进行认证</p></li><li><p><strong>会晤认证</strong>——审查是否允许在访问者和被访问服务器之间建立直接的连接</p></li></ul><h4 id="内容安全检查"><a href="#内容安全检查" class="headerlink" title="内容安全检查"></a><em>内容安全检查</em></h4><ul><li><p>为网络中的每个计算机站点进行<strong>病毒检查</strong></p></li><li><p>为电子邮件服务<strong>提供安全控制的机制</strong>，<strong>该机制可以隐藏Intranet的结构和用户的真实身份等</strong></p></li><li><p><strong>基于FTP命令的内容安全控制</strong>，以禁止用户使用这些命令</p></li></ul><h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a><em>数据加密</em></h4><p>在防火墙中提供了多种加密方案，保障Intranet中信息的安全</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><em>负载均衡</em></h4><p>在多个服务器之间实现负载的均衡，避免出现忙闲不均的现象</p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/be7d62219e877b857a7db22b47298f3f.png" alt="1 ． 以 下 哪 一 种 程 序 （ 或 程 序 片 段 ） 会 自 我 复 制 、 传 播 ， 进 而 威 胁 系 统 的 安 全 ？ A A 计 算 杌 病 毒 B. 特 洛 伊 木 马 C. 逻 辑 炸 弹 D. 操 作 系 统 自 拳 (bootstrap) 文 件"></p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/4c3d91d053be48036e01a878cb998035.png" alt="2 ． 以 下 哪 一 种 机 制 能 够 帮 助 系 统 管 理 员 抵 御 拒 绝 击 (Denial ofService) ？ 0 ． 加 密 A B. 认 证 C. 访 问 控 制 矩 阵 D. 防 火 墙"></p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/f2b1b0e24571821ebaf6885dd553cf6a.png" alt="3. (transparency) ? A C. iüìtmsn messenger\*gËXTk"></p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/1dd3b9cc947e89fcd25a2ac186eb4cd2.png" alt="计算机生成了可选文字: 4 ． 以 下 哪 一 种 程 序 （ 或 程 序 片 段 ） 常 通 过 伪 装 成 其 它 程 序 ， 引 诱 用 户 运 行 ， 从 而 威 胁 系 统 的 安 全 ？ 旦 A 计 算 杌 病 毒 B. 特 洛 伊 木 马 C. 逻 辑 炸 弹 D. 操 作 系 统 自 (bootstrap) 文 件"></p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/fe37a3126745d0ffe00d5f2d20a6e683.png" alt="5 ． 以 下 哪 一 种 机 制 能 够 帮 助 系 统 管 理 员 防 止 击 者 窃 听 在 公 共 网 络 上 传 输 的 数 据 ？ A 加 密 B. 认 证 C. 访 问 控 制 矩 阵 D. 防 火 墙"></p><p><img src="/2018/01/OS-Concept-Chapter-Fourteen/1dd3b9cc947e89fcd25a2ac186eb4cd2.png" alt="计算机生成了可选文字: 4 ． 以 下 哪 一 种 程 序 （ 或 程 序 片 段 ） 常 通 过 伪 装 成 其 它 程 序 ， 引 诱 用 户 运 行 ， 从 而 威 胁 系 统 的 安 全 ？ 旦 A 计 算 杌 病 毒 B. 特 洛 伊 木 马 C. 逻 辑 炸 弹 D. 操 作 系 统 自 (bootstrap) 文 件"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年1月4日&lt;br&gt;08:06&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 数据链路层/Data Link Layer 第三章笔记</title>
    <link href="https://blog.kimisecond.com/2018/01/CN-Chapter-Three/"/>
    <id>https://blog.kimisecond.com/2018/01/CN-Chapter-Three/</id>
    <published>2018-01-03T22:59:26.000Z</published>
    <updated>2018-03-15T11:54:32.844Z</updated>
    
    <content type="html"><![CDATA[<p>2017年10月13日<br>11:03</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><p>由于markdown限制，一些手写部分无法很好转换。如要获得更详细信息，请下载下面提供的mht和pdf.</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i3TE-DSJ0Xmuqnzw" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i3NE55w96MII-dQs" target="_blank" rel="noopener">(pdf)</a></strong></p><p><strong>目标：提供两个相邻机器之间的可靠有效率的通信</strong></p><h2 id="Functions-of-the-Data-Link-Layer"><a href="#Functions-of-the-Data-Link-Layer" class="headerlink" title="Functions of the Data Link Layer"></a>Functions of the Data Link Layer</h2><ul><li>Provide service interface to the network layer</li><li>Dealing with transmission errors</li><li>Regulating data flow: Slow receivers not swamped by fast senders</li></ul><p><img src="/2018/01/CN-Chapter-Three/aa7705c86c203905b8c87f0b9b0cdf86.png" alt=""></p><h3 id="Services-Provided-to-the-Network-Layer"><a href="#Services-Provided-to-the-Network-Layer" class="headerlink" title="Services Provided to the Network Layer"></a><strong>Services Provided to the Network Layer</strong></h3><p><img src="/2018/01/CN-Chapter-Three/b6d2fe0c89fabdf83b1062251e3ca9bd.png" alt=""></p><p>提供了三种服务</p><h4 id="不确认的无连接服务（不确认的服务不可靠）"><a href="#不确认的无连接服务（不确认的服务不可靠）" class="headerlink" title="不确认的无连接服务（不确认的服务不可靠）"></a>不确认的无连接服务（不确认的服务不可靠）</h4><p>应用场合</p><ul><li>出错概率极低</li><li>要求数据实时性高</li><li>大多数局域网</li></ul><h4 id="确认无连接服务"><a href="#确认无连接服务" class="headerlink" title="确认无连接服务"></a>确认无连接服务</h4><ul><li>不可靠信道，比如说无线系统</li></ul><h4 id="确认面向连接服务"><a href="#确认面向连接服务" class="headerlink" title="确认面向连接服务"></a>确认面向连接服务</h4><ul><li>WAN，点到点</li></ul><p>三阶段：</p><ul><li>建立连接</li><li>传输数据帧</li><li>释放连接</li></ul><p>每一帧只会收到一次，且帧以发送顺序接收（确定连接）</p><p><img src="/2018/01/CN-Chapter-Three/758f84c8c43fd7ae9fe9dcd6f278071b.png" alt=""></p><p>收到的数据帧与转发的数据帧可能不一样<br>比如不同端口的协议不同，需要修改格式</p><h3 id="Framing（成帧）"><a href="#Framing（成帧）" class="headerlink" title="Framing（成帧）"></a><strong>Framing（成帧）</strong></h3><h4 id="Character-count（字符计数法）"><a href="#Character-count（字符计数法）" class="headerlink" title="Character count（字符计数法）"></a>Character count（字符计数法）</h4><p><img src="/2018/01/CN-Chapter-Three/0e6f3915d41fc577f4bf3fc3a786aa62.png" alt=""></p><p>在发送的数据帧前面加一个字节，标识数据帧的长度</p><p>缺陷：</p><ul><li>如果数据帧长度不是字符<br>&emsp;&emsp;只能针对以字符为整数倍成帧</li><li>字符计数位出错<br>&emsp;&emsp;出错位之后的数据全部无法解析<br>&emsp;&emsp;（成帧标识出错会影响后面所有数据帧的成帧）</li></ul><h4 id="Flag-bytes-with-byte-stuffing（字符填充法）"><a href="#Flag-bytes-with-byte-stuffing（字符填充法）" class="headerlink" title="Flag bytes with byte stuffing（字符填充法）"></a>Flag bytes with byte stuffing（字符填充法）</h4><p>对字符计数法中第二个缺陷进行改进</p><p><img src="/2018/01/CN-Chapter-Three/76b14838786eacebbb41cb8eb4f03832.png" alt=""></p><p><strong>Need to escape Extra ESCAPE Bytes too!</strong></p><p>Special <em>flag</em> bytes delimit frames; occurrences of flags in the data must be stuffed(escaped)<br>Frames longer, but easier to resynchronize after error</p><p>Example:</p><p>FLAG,A,ESC,FLAG,B,FLAG  </p><p>数据帧的头尾部加上标识（FLAG）<br>ESC：转义字节，在“偶尔”出现的标志位前添加（为大数据块，比如图片等，帧分界受干扰时所设计）<br>接收方的数据链路层在将数据传递给网络层之前<em>必须删除转义字节</em><br>PPP协议使用的略微简化形式</p><p>缺陷：只能针对以字符为整数倍成帧</p><h4 id="Starting-and-ending-flags-with-bit-stuffing（位填充法）"><a href="#Starting-and-ending-flags-with-bit-stuffing（位填充法）" class="headerlink" title="Starting and ending flags, with bit stuffing（位填充法）"></a>Starting and ending flags, with bit stuffing（位填充法）</h4><p>为HDLC（高级数据链路控制）所开发<br>USB中使用</p><p>在数据帧中进行位填充<br>在五个连续1后加入0<br>在接收端，每五个1后的0被删除<br>帧标识有六个1</p><p><img src="/2018/01/CN-Chapter-Three/dd88821380e53395d2a32155f80b591c.png" alt=""></p><h4 id="Physical-layer-coding-violations（物理层违例编码法）"><a href="#Physical-layer-coding-violations（物理层违例编码法）" class="headerlink" title="Physical layer coding violations（物理层违例编码法）"></a>Physical layer coding violations（物理层违例编码法）</h4><p>在以太网中采用</p><p>曼彻斯特编码</p><ul><li>前低后高：0</li><li>前高后低：1</li></ul><p>则有两个违例编码：</p><ul><li>低低/高高</li></ul><p>用违例编码来表示帧始末</p><h3 id="Error-Control（错误控制）"><a href="#Error-Control（错误控制）" class="headerlink" title="Error Control（错误控制）"></a><strong>Error Control（错误控制）</strong></h3><p>检错/纠错<br>检错码/纠错码</p><ul><li>检错码：高度可靠的信道/偶尔发生错误时直接重传整个数据块</li><li>纠错码：错误发生频繁的信道/接收方能够计算出原始的数据块</li><li>检错：奇偶校验码，校验和，循环冗余码</li><li>纠错：海明码（Hamming）</li></ul><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><h5 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h5><p>The minimum bits flips to turn one valid codeword into any other valid one<br>从一种有效码字转换到另外一种至少需要改变多少位（两个码字中不同位的个数）</p><p><img src="/2018/01/CN-Chapter-Three/f67a78360be7c45e9531047548a193f9.png" alt=""></p><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>在原始编码中插入检错位<br>在所有2i的位置都是检错位  </p><p>如下图，1,2,4,8<br>在剩余位中插入原码</p><p><img src="/2018/01/CN-Chapter-Three/36e79235e95652a0f9511b0e5493d9f8.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/fd1d8f3ca434f093f81c15da61f5b563.png" alt=""></p><p>问题：如何确定检测位？</p><p>编号：<br>&emsp;&emsp;1=2^0<br>&emsp;&emsp;2=2^1<br>&emsp;&emsp;3=2^0+2^1  </p><p>确定2^i检测位</p><p>&emsp;&emsp;2^i与编号中有2^i子项的数据，构造偶校验码</p><p>e.g：偶校验例子（和偶为0，和奇为1）</p><p>2^0子项：0  </p><blockquote><p>  3，5，7，9，11<br>  1，0，0，0，1  </p></blockquote><p>2^1子项：0</p><blockquote><p>  3，6，7，10，11<br>  1，0，0，0，1  </p></blockquote><p>2^2子项：0</p><blockquote><p>  5，6，7<br>  0，0，0  </p></blockquote><p>2^3子项：1</p><blockquote><p>  9，10，11<br>  0，0，1  </p></blockquote><h5 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h5><p>Counter（计数器）&lt;—-0<br>对所有的检测位（2^i），判断该检测位与其对应的数据位是否构成偶校验  </p><ul><li>是，计数器不变</li><li>不是，计数器+2^I</li></ul><p>计数器值指示了错误所在位置<br>（11，7）只能纠正一位错，检测两位错</p><p>如果连续出错，则可以将原数据分开发送</p><blockquote><p>  例：7个字符，横向排列编码，再竖向编码发送</p></blockquote><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>在数据末尾加入校验码（比如偶校验：1的个数为偶，校验位为0）<br>单个校验位只能可靠地检测出一位错误<br>这种错误被检测出来的概率只有0.5<br>则将每个数据块作为一个数据矩阵处理<br>对于大批量数据只有少数位出错的情况中，效率很高<br>矩阵检测，则对突发连续错误的检测比较好  </p><h4 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h4><p><img src="/2018/01/CN-Chapter-Three/3524e6711761a3e81dabe005db14131f.png" alt=""></p><p>也称多项式编码<br>将位串堪称是系数为0或1的多项式，进行长除<br>发送方和接收方预先商定一个生成多项式<br>生成多项式的最高位和最低位系数必须是1<br>（不借位除法，可以直接理解为异或）   </p><h4 id="存传机制"><a href="#存传机制" class="headerlink" title="存传机制"></a>存传机制</h4><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><h3 id="Flow-Control（流量控制）"><a href="#Flow-Control（流量控制）" class="headerlink" title="Flow Control（流量控制）"></a><strong>Flow Control（流量控制）</strong></h3><p>数据链路层&amp;传输层</p><h2 id="基本数据链路层协议"><a href="#基本数据链路层协议" class="headerlink" title="基本数据链路层协议"></a>基本数据链路层协议</h2><p><img src="/2018/01/CN-Chapter-Three/7b46e70f97f9ea1fad3aac8646ca70f0.png" alt=""></p><p>协议头文件 protocol.h</p><p><img src="/2018/01/CN-Chapter-Three/0d7d5ad9b1e2bd88369aaf8b79c4bf72.png" alt=""></p><p>一些协议（函数，事件）</p><p><img src="/2018/01/CN-Chapter-Three/d9bff52c6d3918f205f7ef1003bfc4d7.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/3a61a7cf2ed9113c172c0c9f02c58b14.png" alt=""></p><blockquote><p>  在讨论协议前，需要知道，对于理想协议来说，前提十分重要</p></blockquote><h3 id="理想化单工协议-A-Utopian-Simplex-Protocol"><a href="#理想化单工协议-A-Utopian-Simplex-Protocol" class="headerlink" title="理想化单工协议 A Utopian Simplex Protocol"></a>理想化单工协议 A Utopian Simplex Protocol</h3><p>假设</p><ul><li>物理层，数据链路层，网络层是独立进程  </li><li>单向传输  </li><li>物理层服务可靠  </li><li>A有无限数据准备发送  </li><li>B一直准备接收  </li><li>机器不崩溃  </li></ul><p><img src="/2018/01/CN-Chapter-Three/93d5b4182f863c80bd22cfcf213ace14.png" alt=""></p><h3 id="无噪声信道单工停-等协议"><a href="#无噪声信道单工停-等协议" class="headerlink" title="无噪声信道单工停-等协议"></a>无噪声信道单工停-等协议</h3><p>A Simplex Stop-and-Wait Protocol for an Error-Free Channel</p><p>实现了流量控制<br>当接收端收到数据后，发送确认帧</p><p><img src="/2018/01/CN-Chapter-Three/1e4b3bf62883db90e8633f27f8e9e48d.png" alt=""></p><h3 id="有噪声信道单工停-等协议"><a href="#有噪声信道单工停-等协议" class="headerlink" title="有噪声信道单工停-等协议"></a>有噪声信道单工停-等协议</h3><p>不可靠的物理线路</p><p>解决方案</p><ul><li>发送方的数据帧带有CRC</li><li>接收方通过CRC值，发送ACK或NAK（按照序列号分辨）</li><li>发送方在收到ACK之后发送新帧，若NAK或超时则重发老帧</li></ul><p>当ACK丢失<br>&emsp;&emsp;产生重复帧<br>&emsp;&emsp;一个一位序列数字来区别新老帧</p><p>发送进程</p><p><img src="/2018/01/CN-Chapter-Three/2d3e6446d0bca7b9cee57e9d69abc87e.png" alt=""></p><p>接收进程</p><p><img src="/2018/01/CN-Chapter-Three/f8ef1761bef58f60eddcca5678cb4a72.png" alt=""></p><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><h3 id="捎带Piggybacking"><a href="#捎带Piggybacking" class="headerlink" title="捎带Piggybacking"></a>捎带Piggybacking</h3><p>双向发送中，在发送分组时捎带确认帧</p><p>条件：<br>&emsp;&emsp;收到发送的数据帧<br>&emsp;&emsp;接收方有向发送方送回的数据帧（不然发送方无法继续发送，无确认）<br>有时Timeout重发不是因为发送错误，而是因为接收方没有数据发送，而无法捎带确认<br>为避免上述情况，引入（ack_Timer）  </p><blockquote><table><thead><tr><th>分组</th><th>From_network_layer()</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>   网络层</p><table><thead><tr><th>分组</th><th>To_network_layer()</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>  数据链路层</p><table><thead><tr><th>帧</th><th>To_physical_layer()</th></tr></thead><tbody><tr><td>帧</td><td>From_physical_layer()</td></tr></tbody></table><p>  物理层</p></blockquote><p>发送端给接收端发送包F0，接收端可能：</p><ul><li><p>CRC检测出错<br>&emsp;&emsp;接收端发送确认错误帧让发送端重发F0（1）</p></li><li><p>在传输中丢失此包<br>&emsp;&emsp;接收端无回复确认帧，接收端等Timeout之后重发F0(1)</p></li></ul><p>正确到达，发送确认帧，确认帧可能：</p><ul><li><p>在传输中丢失此包<br>&emsp;&emsp;发送端Timeout，重发</p></li><li><p>正确到达<br>&emsp;&emsp;完成一次成功传输</p></li></ul><p>停等协议流程图</p><p><img src="/2018/01/CN-Chapter-Three/d64325a0c67355b0a41f7251e786fd77.png" alt=""></p><p>停等协议线路利用率</p><p><img src="/2018/01/CN-Chapter-Three/7f00d0b8e1ec317d1f37a4e5395dcd52.png" alt=""></p><h3 id="1位滑动窗口协议"><a href="#1位滑动窗口协议" class="headerlink" title="1位滑动窗口协议"></a>1位滑动窗口协议</h3><ul><li>数据传输双向</li><li>捎带</li></ul><p>滑动窗口</p><ul><li>序列号</li><li>大小</li><li>上边界指针，下边界指针（决定窗口大小）</li></ul><p>发送窗口</p><ul><li>帧已发送但未收到确认帧</li><li>缓存这些确认帧（缓冲区）</li><li>发送新数据帧，上界指针+1</li><li>收到确认桢，下界指针+1</li><li>上下界指针变更<em>不同步</em></li></ul><p>接收窗口</p><ul><li>可接收的帧</li><li>上下界指针同步变更</li></ul><p><img src="/2018/01/CN-Chapter-Three/f4ca265d8bdd834a7fa86c015fe3f4b7.png" alt=""></p><p>以圆盘表示滑动窗口，序列号几位决定扇形区域多少</p><p>当窗口大小=1（目前的例子），接收数据帧的顺序与发送数据的顺序一致</p><p>而大小&gt;1，可以不一致（选择性存传协议）</p><p><img src="/2018/01/CN-Chapter-Three/fbee5dbbfbabf7385a73a40302130deb.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/e9c81707a580175b32e359142d982717.png" alt=""></p><blockquote><p>  实际上还是停等协议，只不过双工</p></blockquote><p><img src="/2018/01/CN-Chapter-Three/ec8388a5c3017b4fbc8bfa5594f2bee1.png" alt=""></p><p>区分主从站点，从站点协议中没有第一次发送过程（to_physical_layer(&amp;s);start_timer(s.seq);）</p><blockquote><p>  原因：会导致第一次发送时，发送站点浪费一次发送</p></blockquote><p><img src="/2018/01/CN-Chapter-Three/a7a24f3d1d9d69a12cf886ebee270296.png" alt=""></p><p>利用率和停等协议相当</p><h3 id="回退N帧协议"><a href="#回退N帧协议" class="headerlink" title="回退N帧协议"></a>回退N帧协议</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>利用率</td><td>up</td></tr><tr><td>适用场合</td><td>出错率低</td></tr><tr><td>发送窗口大小</td><td>0~2n-1</td></tr><tr><td>接收窗口大小</td><td>1</td></tr></tbody></table><p>收到n号确认—->n号到发送窗口下界指针的帧都被确认</p><p>当出错数据帧发生定时时间溢出，指针回退到出错数据帧，重发到上边界指针</p><p><img src="/2018/01/CN-Chapter-Three/a24371b737bf03651ceb4f6d95ac9ad0.png" alt=""></p><h3 id="选择性存传协议"><a href="#选择性存传协议" class="headerlink" title="选择性存传协议"></a>选择性存传协议</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>利用率</td><td>up</td></tr><tr><td>适用场合</td><td>出错率高</td></tr><tr><td>发送窗口大小</td><td>0~2n-1</td></tr><tr><td>接收窗口大小</td><td>2n-1</td></tr></tbody></table><p>n为序列号位数<br>接收窗口指针同步滑动<br>下界指针只会收到时滑动<br>发送端等收到确认帧之后再发下一帧</p><p><img src="/2018/01/CN-Chapter-Three/b71144b8374af7e7823abd02c7eb1ab0.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/44759957f4fd868ca73e863091cc39c2.png" alt="]"></p><h2 id="Example-Data-Link-Protocols"><a href="#Example-Data-Link-Protocols" class="headerlink" title="Example Data Link Protocols"></a><strong>Example Data Link Protocols</strong></h2><h3 id="HDLC高级数据链路控制协议"><a href="#HDLC高级数据链路控制协议" class="headerlink" title="HDLC高级数据链路控制协议"></a>HDLC高级数据链路控制协议</h3><blockquote><p>  全双工<br>  滑动窗口协议<br>  面向连接的可靠传输<br>  无序号帧用于链路连接的建立、维护和拆除<br>  信息帧用于发送数据并实现捎带的帧确认<br>  监控帧用于告诉对方数据帧传输出错并同时给出建议的差错控制方式</p></blockquote><p><img src="/2018/01/CN-Chapter-Three/9a5a8c76c18788cc312c2fc885c28897.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/63f93765cc0ba01684d1d2ab02bd4b33.png" alt=""></p><p>P/F用来指示此帧是否为本次传输最后一帧</p><p><img src="/2018/01/CN-Chapter-Three/eb9a48b162971f1ce7a78f190e125ec2.png" alt=""></p><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><h4 id="PPP架构"><a href="#PPP架构" class="headerlink" title="PPP架构"></a>PPP架构</h4><p><img src="/2018/01/CN-Chapter-Three/1a11890c04eb21df563cc6567d5d1f80.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Three/a4e2daf348ddf935efc01357b9f6bfc6.png" alt=""></p><h4 id="PPP帧格式"><a href="#PPP帧格式" class="headerlink" title="PPP帧格式"></a>PPP帧格式</h4><p><img src="/2018/01/CN-Chapter-Three/7994a06376c2b0e4cdff779dbe09ab6e.png" alt=""></p><p>面向字符，字符填充成帧  </p><p>会话建立过程  </p><ul><li>链路的建立和配置协调  </li><li>链路质量检测  </li><li>网络层协议配置协调  </li><li>关闭链路</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年10月13日&lt;br&gt;11:03&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
&lt;p&gt;由于markdown限制，一些手写部分无法很好转换。如要获得更详细信息，请下载下面提供的mht和pdf.&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="Computer_Network" scheme="https://blog.kimisecond.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 物理层/Physical Layer 第二章笔记</title>
    <link href="https://blog.kimisecond.com/2018/01/CN-Chapter-Two/"/>
    <id>https://blog.kimisecond.com/2018/01/CN-Chapter-Two/</id>
    <published>2018-01-03T00:36:00.000Z</published>
    <updated>2018-03-15T11:54:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月20日<br>08:54</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i3LdIdBMmldwsaow" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i3Edt0_h5wtExjkk" target="_blank" rel="noopener">(pdf)</a></strong></p><p><img src="/2018/01/CN-Chapter-Two/eb005ca13a025b4747714ec226f813a0.png" alt=""></p><p>Synchronous(同步)  </p><blockquote><p>  有一个基准时钟信号  </p></blockquote><p>synchronous(异步)  </p><blockquote><p>  没有基准，当需要传输信号时即传输</p></blockquote><p><img src="/2018/01/CN-Chapter-Two/d8fbc19b6c4e73bb9db1c0bdf8e268e9.png" alt=""></p><ul><li>异步传输：适合低速通讯</li></ul><p><img src="/2018/01/CN-Chapter-Two/3481ebb07c2847370da51a7a1fee226f.png" alt=""></p><ul><li>模拟通信系统<br>在模拟信号的基础上加入编码器和译码器（信源信道个需要一个）</li></ul><p><img src="/2018/01/CN-Chapter-Two/4b6817131c61f2a75f947f387304e6a7.png" alt=""></p><ul><li>数字通信系统<br>在模拟信号的基础上加入编码器和译码器（信源信道个需要一个）</li></ul><h2 id="数据传输的理论基础"><a href="#数据传输的理论基础" class="headerlink" title="数据传输的理论基础"></a>数据传输的理论基础</h2><h3 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h3><h3 id="有限带宽信号"><a href="#有限带宽信号" class="headerlink" title="有限带宽信号"></a>有限带宽信号</h3><p><img src="/2018/01/CN-Chapter-Two/7ac5359f12bba7d6d8a97b053ecd86de.png" alt=""></p><p>谐波数选取越多，傅里叶分析之后得到的结果失真越小   </p><blockquote><p>  （一般来说谐波数>=4）</p></blockquote><p><img src="/2018/01/CN-Chapter-Two/c513a71debb75d840b71d9080567cf6b.png" alt=""></p><h3 id="信道的最大数据传输率"><a href="#信道的最大数据传输率" class="headerlink" title="信道的最大数据传输率"></a>信道的最大数据传输率</h3><h4 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts:"></a>Concepts:</h4><ul><li><p><strong>Bandwidth</strong>: the range of frequency<br>带宽，又叫频宽，是数据的传输能力，指单位时间按内<strong>能够</strong>传输的比特数。数字设备中带宽用bps表示，模拟设备中用Hz表示</p></li><li><p><strong>Symbol（码元）</strong>: one piece info., a sample（一个波特即为一个码元）</p></li><li><p><strong>Baud rate (RB 波特率)</strong>: The number of changes in the signal per second, number of sample/sec, symbol rate<br>波特率，又称调制速率、传符号率（符号又称单位码元），指单位时间内载波参数变化的次数，可以以波形每秒的振荡数来横梁，是信号传输速率的度量。</p></li><li><p><strong>Bit Rate (Rb 比特率)</strong>: number of symbol/sec times number of bits/symbol<br>码元速率和信息速率的关系式为：Rb=RB*log2(N)。其中，N为进制数  </p></li><li><p>理想低通信道<br>最高RB=2H Baud。每秒2码元<br>信号所有低频分量，只要频率不超过上限，则可不失真传输。</p></li><li><p>理想带通信道：最高码元传输速率则是：RB=H Baud。每秒1码元<br>带通：只允许上下限之间信号频率成分不失真的通过</p></li></ul><h4 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h4><ul><li><strong>Nyquist’s theorem</strong><br><strong>任意信号通过一个带宽为B的低通滤波器，那么只要进行每秒2B次（确切）采样，就可以完全重构出被过滤的信号。</strong><br><strong>高于2B毫无意义</strong></li></ul><blockquote><p>  <strong>maximum data rate = 2H log2 V bits/sec</strong>&emsp;V：信号有V个不同离散等级</p></blockquote><ul><li><strong>Shannon’s theorem</strong><br><strong>maximum data rate = Hlog2 (1+S/N) bits/sec</strong>  </li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>S/N：10log（S/N）=dB</td><td>10，10</td></tr><tr><td></td><td>100，20</td></tr></tbody></table><p>例子：<br>若现V=2，H=3000<br>尼奎斯特：  </p><blockquote><p>  Rmax=2*Hlog2(V)=6kbps  </p></blockquote><p>Shannon:  </p><blockquote><p>  Rmax=30Kbps  </p></blockquote><p>则取<em>最小值</em></p><h2 id="信号传输介质"><a href="#信号传输介质" class="headerlink" title="信号传输介质"></a>信号传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>绞数越多，频繁，传输速率越快</p><h3 id="同轴电缆："><a href="#同轴电缆：" class="headerlink" title="同轴电缆："></a>同轴电缆：</h3><ul><li><p>基带同轴电缆</p></li><li><p>宽带同轴电缆<br>中继器，在信号衰减严重之前对信号进行重新整形</p></li></ul><p>铜芯、绝缘材料、导体网、保护性塑料套</p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p>问题：不同情况所采用的电线性质可能不同，高频信号衰减严重，且还未有国际标准</p><h3 id="光纤：（单工）"><a href="#光纤：（单工）" class="headerlink" title="光纤：（单工）"></a>光纤：（单工）</h3><p><img src="/2018/01/CN-Chapter-Two/a7cef572e8c862b2c9dc7e302d0c566a.png" alt=""></p><p>单模，多模光纤</p><p><img src="/2018/01/CN-Chapter-Two/dedf7160430c60c70133232b40cc7386.png" alt=""></p><p>光纤的规格通常用玻璃芯与覆层的直径比值来表示。</p><p>单模光纤的传输率较高，但比多模光纤更难制造，价格更高。</p><h4 id="光纤信号计算问题"><a href="#光纤信号计算问题" class="headerlink" title="光纤信号计算问题"></a>光纤信号计算问题</h4><p><img src="/2018/01/CN-Chapter-Two/693ea0246ba7c9398efd95c1aeb77e04.png" alt=""></p><p>Δλ：波长，波宽</p><p>Δf：频宽</p><p><strong>Solution:</strong></p><ul><li><p>The data rate is 1024 ×768 ×24 ×60 bps, which is 1080 Mbps.</p></li><li><p>For simplicity, let us assume 1 bps per Hz.</p></li></ul><blockquote><p>  we get <strong>Δ</strong> λ =λ^2 <strong>Δ</strong> <em>f /</em>c. We have <strong>Δ</strong> <em>f</em> = 1.08 ×10^9 , so <strong>Δ</strong> λ=6.08 ×10^(-10) microns. The range of wavelengths used is very short.</p></blockquote><h4 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h4><p>LED性能差寿命长使用环境不严苛<br>半导体激光相反</p><p><img src="/2018/01/CN-Chapter-Two/5915292235eb5c6f78b428cb37f3208a.png" alt="">   </p><p><img src="/2018/01/CN-Chapter-Two/05b79a74c989aed2eaca0361430d150d.png" alt=""></p><h2 id="Wireless-Transmission"><a href="#Wireless-Transmission" class="headerlink" title="Wireless Transmission"></a>Wireless Transmission</h2><h3 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h3><p><img src="/2018/01/CN-Chapter-Two/a3675dd53c8103829f887b7682115aa1.png" alt=""></p><h3 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h3><p><img src="/2018/01/CN-Chapter-Two/46885abe6454bead52989b314827db1b.png" alt=""></p><h3 id="光波通信"><a href="#光波通信" class="headerlink" title="光波通信"></a>光波通信</h3><p><img src="/2018/01/CN-Chapter-Two/b7e70387bb55ba6f599cd5d464a48ddf.png" alt=""></p><p>只能直线</p><p>有水蒸气的时候会影响通信</p><h2 id="通信卫星"><a href="#通信卫星" class="headerlink" title="通信卫星"></a>通信卫星</h2><p><img src="/2018/01/CN-Chapter-Two/d997c07064e4485b0aad8aedb2b8eab2.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Two/3d418690799437da7bfb27f3d45df1fa.png" alt=""></p><p>低频段受干扰小，但是带宽小，比较拥挤</p><p>高频段带宽大，但是受干扰大，会受到降雨等因素干扰</p><blockquote></blockquote><h2 id="PSTN-Public-Switched-Telephone-Network"><a href="#PSTN-Public-Switched-Telephone-Network" class="headerlink" title="PSTN (Public Switched Telephone Network)"></a>PSTN (Public Switched Telephone Network)</h2><p><img src="/2018/01/CN-Chapter-Two/f218d67a376bbad2f2a97e452bf578f1.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Two/ec2e36e01c5242acd00e7eb175069f07.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Two/ef19fa7ec46fd27a6895a63f35402c34.png" alt=""></p><h2 id="信号调制"><a href="#信号调制" class="headerlink" title="信号调制"></a>信号调制</h2><p><img src="/2018/01/CN-Chapter-Two/900c26a2118c23c06b402007d10f8f75.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Two/f4fe2ec6be6e80f2c0092564b2c93a78.png" alt=""></p><p>角度为相位，距离为振幅。对不同信号加载不同信号可以实现<strong>一个周期内传输多位数据</strong></p><p><em>在带宽较小的情况下提高数据传输速度</em></p><h3 id="基带传输-Baseband-transmission-P98"><a href="#基带传输-Baseband-transmission-P98" class="headerlink" title="基带传输(Baseband transmission) P98"></a>基带传输(Baseband transmission) P98</h3><p><img src="/2018/01/CN-Chapter-Two/20470d2986e7d860008addf4fbbee1d7.png" alt=""></p><h4 id="四种不同编码方式："><a href="#四种不同编码方式：" class="headerlink" title="四种不同编码方式："></a>四种不同编码方式：</h4><ul><li>NRZ （Non-Return to Zero）</li><li>NRZI （NRZ Revert）</li><li>Manchester</li><li>AMI</li></ul><table><thead><tr><th><strong>编码名称</strong></th><th><strong>编码规则</strong></th></tr></thead><tbody><tr><td><strong>不归零码 Nonreturn-to-Zero-Level(NRZ-L)</strong></td><td><strong>0 = 低电平 1 = 高电平</strong></td></tr><tr><td><strong>反向不归零码 Nonreturn to Zero Inverted(NRZI)</strong></td><td><strong>0 = 间隔(一个bit的时间)起始处无变化 1 = 间隔起始处有变化</strong></td></tr><tr><td><strong>双极-AMI码</strong></td><td><strong>0 = 无信号 1 = 正、或负电平,每一连续的1交变</strong></td></tr><tr><td><strong>Manchester编码</strong></td><td><strong>0 = 间隔的中央处从低到高变化 1 = 间隔的中央处从高到低变化</strong></td></tr><tr><td><strong>差分 Manchester编码</strong></td><td><strong>间隔的中央处总有变化 0 = 在间隔起始处变化 1 = 间隔起始处无变化</strong></td></tr></tbody></table><p>NRZI编码方式会遇到一个严重问题，当连续发送多位“0”或“1”信号时，会造成数据信号长时间无法翻转，使读取的时序发生严重错误（接收端时钟与发信端时钟会有误差）。因此，在NRZI编码之间还需执行所谓的位填充的工作。</p><p><img src="/2018/01/CN-Chapter-Two/51e13a451f8bf3ff0f7d68bd34599d1d.png" alt=""></p><h4 id="四五位编码"><a href="#四五位编码" class="headerlink" title="四五位编码"></a>四五位编码</h4><p><img src="/2018/01/CN-Chapter-Two/76838c8316bdd2e06cea20f57dbe6fc5.png" alt=""></p><p>有意识地让一段数据一定会产生电平跳变（浪费25%带宽）（保证传输准确性）</p><blockquote><p>  DSL（Digital Subscriber Lines）数字用户环线</p><p>  带宽会因为传输距离而衰减</p></blockquote><p><img src="/2018/01/CN-Chapter-Two/8c934b9d2143d0ef16ea5eee995af672.png" alt=""></p><blockquote><p>  上图为三类UTP数值</p><p>  ADSL 非对称</p></blockquote><p><img src="/2018/01/CN-Chapter-Two/3709149d13742e8a63ef4e90b3bf66ee.png" alt=""></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><blockquote><p>  把许多信号在单一地传输线路和用单一的传输设备来进行传输的技术。</p></blockquote><p>在语音信号中，比如有三路不同语音信号<br>将这三路信号升频，进入三个不同的频率段</p><h4 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用(FDM)"></a>频分复用(FDM)</h4><p><img src="/2018/01/CN-Chapter-Two/953a57223326db69aa4b304891e83410.png" alt=""></p><p>上述方法固定频率段，但是无法控制不同频率段使用效率的差距问题</p><p>信号并行发送</p><h4 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用(TDM)"></a>时分复用(TDM)</h4><p>用户以循环的方式轮流工作。每个用户周期性地获得整个带宽非常短的一个时间</p><p><img src="/2018/01/CN-Chapter-Two/380ada5984df75523083b9d9e26751c0.png" alt=""></p><p>信号串行发送</p><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p>把频分的频率看成波长（光信号）</p><h4 id="PCM-Pulse-Code-Modulation"><a href="#PCM-Pulse-Code-Modulation" class="headerlink" title="PCM (Pulse Code Modulation)"></a>PCM (Pulse Code Modulation)</h4><p>Nyquist theorem: Making 2N samples per second from N hz bandwidth is sufficient to capture all the information</p><p>Telephone system: 8000 samples from 4khz channel, 125us/sample, 7 or 8 bit/sample</p><p><img src="/2018/01/CN-Chapter-Two/e2f6effec9ebd6f981011eb3ca52e34b.png" alt="">   </p><p><img src="/2018/01/CN-Chapter-Two/c9d3e009b54365b56fe671f07ffc2b8a.png" alt=""><br>简单的采样量化过程</p><h4 id="增量调制（Delta-Modulation）"><a href="#增量调制（Delta-Modulation）" class="headerlink" title="增量调制（Delta Modulation）"></a>增量调制（Delta Modulation）</h4><p>一种差分编码，减少了一个通道所需要的比特位数</p><p>Delta 1bit</p><p>Differential 5bits 一般</p><p><img src="/2018/01/CN-Chapter-Two/a001cc72217e3ef9fe025fb2b298fe61.png" alt=""></p><p>将多路T1复用到更高的带宽中</p><blockquote></blockquote><h2 id="Switching-交换"><a href="#Switching-交换" class="headerlink" title="Switching/交换"></a>Switching/交换</h2><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><p><img src="/2018/01/CN-Chapter-Two/49abeb7ef6620de92932ade0e463d5d9.png" alt=""></p><h3 id="电路交换-amp-分组交换"><a href="#电路交换-amp-分组交换" class="headerlink" title="电路交换&amp;分组交换"></a>电路交换&amp;分组交换</h3><p>交换机收到一个分组之后就可以向下传递，不需要等待所有分组全部收到</p><p><img src="/2018/01/CN-Chapter-Two/152a0e17c457c1a80d5233fa133994fa.png" alt=""></p><p>电路交换：时延主要在寻找中继线的时候，线路延时较小</p><p>分组交换：分组较一大块数据块小很多，不需要等待则时延小一些</p><p>比较：</p><p><img src="/2018/01/CN-Chapter-Two/fd50bf3f7432e2d0c40c80dc61767b60.png" alt=""></p><h3 id="Congestion-拥塞："><a href="#Congestion-拥塞：" class="headerlink" title="Congestion 拥塞："></a>Congestion 拥塞：</h3><p>当<em>线路利用率达到某一个临界值</em>时，线路将会被堵塞<br>如果继续按照原有的速率发送数据包，则数据包会发生拥塞<br>在此情况下数据包会<em>遭到破坏</em><br><em>解决方法：将发送端加载数据包的速度降低</em><br><strong>拥塞策略</strong></p><h2 id="移动电话系统"><a href="#移动电话系统" class="headerlink" title="移动电话系统"></a>移动电话系统</h2><p>AMPS/GSM/UMTS/LTE</p><h3 id="AMPS（1G）"><a href="#AMPS（1G）" class="headerlink" title="AMPS（1G）"></a>AMPS（1G）</h3><p>语音仍模拟传输<br>信号调制基于频率</p><p><img src="/2018/01/CN-Chapter-Two/a72f5c10a45231a234323338eda3e2aa.png" alt=""></p><p>每段频率段各不相同，A~F</p><p>每个区域分为七个小区域，分别部署七个不同频率段</p><p>再将每个区域细分到832个<strong>（全双工）</strong>信道，其中有四类：</p><ul><li>控制信道用于管理系统<strong>（基站到移动电话）</strong></li><li>寻呼信道用于提醒用户有呼叫到来<strong>（基站到移动电话）</strong></li><li>计入（Access）信道用于呼叫的建立和信道分配<strong>（双向）</strong></li><li>数据信道承载语音、传真或数据<strong>（双向）</strong></li></ul><p>发送信道<strong>（移动电话到基站）</strong>824~849MHz<strong>（单工）</strong>832个信道<br>接受信道<strong>（基站到移动电话）</strong>869~894MHz<strong>（单工）</strong>832个信道</p><h3 id="D-AMPS（2G）"><a href="#D-AMPS（2G）" class="headerlink" title="D-AMPS（2G）"></a>D-AMPS（2G）</h3><p>数字传输<br>TDM帧</p><p><img src="/2018/01/CN-Chapter-Two/b0c30575676a911f2bcaba97f71f470e.png" alt=""></p><h3 id="GSM（2G）"><a href="#GSM（2G）" class="headerlink" title="GSM（2G）"></a>GSM（2G）</h3><p>FDM多频道，TDM单帧</p><p><img src="/2018/01/CN-Chapter-Two/10ec6dee9d541813bf66a4d8f511be8f.png" alt=""></p><p><img src="/2018/01/CN-Chapter-Two/ee4e7b36db2fdaa58691a060d5ba4bf5.png" alt=""></p><p>信号调制基于QPSK（正交相移键控）</p><h3 id="UMTS（2G）"><a href="#UMTS（2G）" class="headerlink" title="UMTS（2G）"></a>UMTS（2G）</h3><p>信号调制基于CDMA（3G）<br>多路信号同时占用整个带宽传输  </p><p>如何从合成信号中分解单路信号？</p><p><img src="/2018/01/CN-Chapter-Two/a70cc97a77641d2259f504636506e7bd.png" alt=""></p><p>芯片码（正交）<br>站点发送</p><ul><li>芯片码“1”</li><li>芯片码的反码“0”</li></ul><p>合成信号·发送站芯片码/码长=+1/-1/0（信号还原）<br>通过基站交换双方的芯片码</p><h3 id="LTE（4G）"><a href="#LTE（4G）" class="headerlink" title="LTE（4G）"></a>LTE（4G）</h3><p>OFDM（正交频分多路复用）</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>2.1 The theoretical basis for data communication</p><ul><li>Bandwidth analysis (综合分析)</li><li>The maximum data rate of a channel (综合分析)</li></ul><p>2.2 Guide transmission media （了解）<br>2.3 wireless transmission（理解）  </p><ul><li>Light wave transmission （理解）  </li></ul><p>2.4 Communication satellites （了解）<br>2.5 The public switched telephone network （理解）  </p><ul><li>Structure of the telephone system</li><li>The local loop: Modems</li><li>Trunks and Multiplexing</li><li>Switching</li></ul><p>2.6 the mobile telephone system  </p><ul><li>GSM and CDMA (综合分析)  </li></ul><p>2.7 cable television（了解）</p><blockquote></blockquote><p>gtmd作业</p><blockquote><p>  2.3，2.4，2.5，2.7，2.10，2.19，2.21，2.25，2.26，2.28 ，2.44 ，2.48, 2.50</p></blockquote><table><thead><tr><th>2.3</th><th>If a binary signal is sent over a 3-kHz channel whose signa-to-noise ratio is 20dB, what is the maximum achievable data rate?</th></tr></thead><tbody><tr><td>2.4</td><td>What signal-to-noise ratio is needed to put a T1 carrier on a 100-kHz line?</td></tr><tr><td>*2.5</td><td>What are the advantages of fiber optics over copper as a transmission medium? Is there any downside of using fiber optics over copper?</td></tr><tr><td>2.6</td><td>How much bandwidth is there in 0.1 microns of spectrum at a wavelength of 1 micron?</td></tr><tr><td>2.7</td><td>It is desired to send a sequence of computer screen images over an optical fiber. The screen is 1920x1200 pixels, each pixel being 24 bits. There are 50 screen images per second. How much bandwidth is needed?</td></tr><tr><td>2.10</td><td>Radio antennas often work best when the diameter of the antenna is equal to the wave-length of the radio wave. Reasonable antennas range from 1cm to 5 meters in diameter. What frequency range does this cover?</td></tr><tr><td>2.19</td><td>Is an oil pipeline a simplex system, a half-duplex system, a full-duplex system, or none of the above? What about a river or a walkie-talkie-style communication?</td></tr><tr><td>2.21</td><td>A modem constellation diagram similar to Fig. 2-23 has data points at (0,1) and (0,2). Does the modem use phase modulation or amplitude modulation?</td></tr><tr><td>2.25</td><td>Ten signals, each requiring 4000 Hz, are multiplexed onto a single channel using FDM. What is the minimum bandwidth required for the multiplexed channel? Assume that the guard bands are 400 Hz wide.</td></tr><tr><td>2.26</td><td>Why has the PCM sampling time been set at 125 μsec?</td></tr><tr><td>2.28</td><td>Compare the maximum data rate of a noiseless 4-kHz channel using (a) Analog encoding (e.g., QPSK) with 2 bits per sample (b) The T1 PCM system</td></tr><tr><td>2.44</td><td>A CDMA receiver gets the following chips:(-1 +1 -3 +1 -1 -3 +1 +1). Assuming the chip sequences defined in Fig. 2-28(a), which stations transmitted, and which bits did each one send?</td></tr><tr><td>2.48</td><td>A cable company decides to provide Internet access over cable in a neighborhood consisting of 5000 houses. The company uses a coaxial cable and spectrum allocation allowing 100Mbps downstream bandwidth per cable. To attract customers, the company decides to guarantee at least 2Mbps downstream bandwidth to each house at any time. Describe what the cable company needs to do to provide this guarantee.</td></tr><tr><td>2.50</td><td>How fast can a cable user receive data if the network is otherwise idle? Assume that the user interface is (a) 10Mbps Ethernet (b) 100Mbps Ethernet (c) 54Mbps Wireless                             </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月20日&lt;br&gt;08:54&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="Computer_Network" scheme="https://blog.kimisecond.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 序言/Introduction 第一章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/CN-Chapter-One/"/>
    <id>https://blog.kimisecond.com/2017/12/CN-Chapter-One/</id>
    <published>2017-12-24T13:36:24.000Z</published>
    <updated>2018-03-15T11:54:23.497Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月13日<br>08:08</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i23vpeKJ-d4pQU5L" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i2yVRgDfA2JoKNjB" target="_blank" rel="noopener">(pdf)</a></strong></p><p>P2P peer-to-peer 对等（no fixed clients and servers/地位平等）<br>*：进程 计算机系统 实体 计算机网络<br>对于P2P，实体皆对等  </p><p><img src="/2017/12/CN-Chapter-One/be8a90fc5b86a1ec4ef90a39487c0f58.png" alt=""></p><p>每层协议实体对等</p><p><strong>一个商业应用的典型例子</strong></p><p><img src="/2017/12/CN-Chapter-One/d57cd5a23925c524aba52720ce5d16ad.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/5748c4b5a33deaa1668b839b38c94649.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/8738f216c500fa40befa29ad74e55399.png" alt=""></p><p>对于这样的架构，计算机网络需要对所有请求和回复数据包做处理</p><h2 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a><strong>网络分类</strong></h2><h3 id="计算机网络传输技术："><a href="#计算机网络传输技术：" class="headerlink" title="计算机网络传输技术："></a>计算机网络传输技术：</h3><p>（Broadcast Networks 广播式网络）</p><ul><li>广播式联接 broadcast links /卫星网络 局域网  </li><li>点-点联接 Point-to-point links （子网）<br>*：以上技术和网络安全性无关不影响网络安全性</li></ul><h3 id="对网络规模的分类：P18"><a href="#对网络规模的分类：P18" class="headerlink" title="对网络规模的分类：P18"></a>对网络规模的分类：P18</h3><p>PAN/ LAN/ MAN/ WAN/ The Internet</p><h3 id="局域网（LAN）拓补结构："><a href="#局域网（LAN）拓补结构：" class="headerlink" title="局域网（LAN）拓补结构："></a>局域网（LAN）拓补结构：</h3><ul><li>主线式（常用） 一台机器损坏不会影响整个网络  </li><li>环状 环中任一机器损坏会导致令牌(token)传输出现问题</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>城域网（MAN）</td><td>有线电视</td></tr><tr><td>广域网（WAN）</td><td>由若干LAN构成，而中间由子网来构建通讯（子网和主机）</td></tr></tbody></table><p><img src="/2017/12/CN-Chapter-One/01f0d5190a3797b18b0d963315577759.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/fa0d43815ef575ef9ab4b9c88a9676d9.png" alt=""></p><p>子网内数据传输：点对点<br>局域网内：广播</p><p>局域网之间互联：局域网主机广播至路由器端口，路由器通过子网转发给另一个路由器，再由另一个路由器广播至另一局域网主机</p><p><img src="/2017/12/CN-Chapter-One/475388cb71c03f131708153b98171db5.png" alt=""></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>存储/转发</td><td>解决可能的不同线路特征问题，比如带宽差距</td></tr><tr><td></td><td>检测分组可能存在的错误，屏蔽并重新请求</td></tr><tr><td></td><td>决定向谁转发</td></tr></tbody></table><blockquote><p>  与以上种类网络不同，还有一种网络为直通式网络，即对所有分包不做任何处理直接传输</p></blockquote><h2 id="网络软件（应用）"><a href="#网络软件（应用）" class="headerlink" title="网络软件（应用）"></a>网络软件（应用）</h2><ul><li>Connection-Oriented and Connectionless Services  </li><li>Service Primitives  </li><li>The Relationships of Services to Protocols</li></ul><h3 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a><strong>网络体系结构</strong></h3><p>完成计算机之间的通信合作，把每个计算机互联的功能划分成有明确定义的层次，并规定同层次进程通信的<strong>协议</strong>及相邻层之间的<strong>接口</strong>服务</p><h3 id="协议（protocol）："><a href="#协议（protocol）：" class="headerlink" title="协议（protocol）："></a><strong>协议（protocol）</strong>：</h3><p>协议就是为实现网络中的数据交换建立的规则标准或约定。协议由<strong>语法、语义和交换规则</strong>三部分组成，即协议的三要素。</p><h3 id="接口（interface）："><a href="#接口（interface）：" class="headerlink" title="接口（interface）："></a><strong>接口（interface）</strong>：</h3><p>分层结构中各相邻层之间要有一个<strong>接口</strong>，它定义了较低层向较高层提供的原始操作和服务。相邻层通过它们之间的<strong>接口</strong>交换信息，高层并不需要知道低层是如何实现的，仅需要知道该层通过层间的<strong>接口</strong>所提供的服务，这样使得两层之间保持了功能的独立层通过它们之间的<strong>接口</strong>交换信息，高层并不需要知道低层是如何实现的，仅需要知道该层通过层间的<strong>接口</strong>所提供的服务，这样使得两层之间保持了功能的独立</p><p><img src="/2017/12/CN-Chapter-One/ea4b9349abc3257c482c707321f0c509.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/be8a90fc5b86a1ec4ef90a39487c0f58.png" alt=""></p><h3 id="层设计的问题"><a href="#层设计的问题" class="headerlink" title="层设计的问题"></a><strong>层设计的问题</strong></h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Addressing</td><td>寻址</td></tr><tr><td>Error Control</td><td>错误控制</td></tr><tr><td>Flow Control</td><td>流量控制</td></tr><tr><td>Multiplexing</td><td>复用技术</td></tr><tr><td>Routing</td><td>路由</td></tr></tbody></table><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p>&emsp;&emsp;IP地址，MAC地址</p><h4 id="错误控制（非可靠）"><a href="#错误控制（非可靠）" class="headerlink" title="错误控制（非可靠）"></a>错误控制（非可靠）</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>检错</td><td>海明码</td></tr><tr><td></td><td>CRC</td></tr><tr><td>纠错</td><td>纠错码</td></tr><tr><td></td><td>重传</td></tr></tbody></table><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>当发送速率和接收速率的速度不一致，若不进行流量控制，则会产生<strong>信息淹没</strong>方式：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>基于速率</td><td></td></tr><tr><td><em>基于反馈（本课程）</em></td><td>在一个数据单元结束做标识，接收设备得到标识符之后发送给发送端信号</td></tr><tr><td><em>\</em>第三章*</td><td>线路利用率下降</td></tr></tbody></table><h4 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h4><ul><li>频分  </li><li>时分（波分）  </li><li>CDMA</li></ul><h3 id="面向连接和无连接服务"><a href="#面向连接和无连接服务" class="headerlink" title="面向连接和无连接服务"></a>面向连接和无连接服务</h3><h4 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h4><p>Like the phone system  </p><p>三阶段</p><ul><li>Connection Setup  </li><li>Data Transfer  </li><li>Connection Termination  </li></ul><p>发送数据和接收数据的<em>顺序一致</em><br>发送数据的<em>路径一致</em>  </p><p>发送数据头部（连接号：ID）<br>*第五章，第六章</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>Like the post office</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Each message has the entire address on it</td><td>发送报文必须包含完整地址信息</td></tr><tr><td>Each message may follow a different route to its destination</td><td>报文独立进行路由</td></tr><tr><td></td><td>各报文传输路径可能不一致</td></tr><tr><td>Data Transfer</td><td>发送接收顺序可能不一致</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>DNS</td><td>域名解析：面向连接</td></tr><tr><td></td><td>域名映射表：无连接</td></tr></tbody></table><h4 id="服务及例子"><a href="#服务及例子" class="headerlink" title="服务及例子"></a>服务及例子</h4><p><img src="/2017/12/CN-Chapter-One/54d216d6852d87fd439a9bc05304f3de.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/7289a4d51833eb32a6b7f52b1fd63871.png" alt=""></p><h3 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h3><p><img src="/2017/12/CN-Chapter-One/14f12f0f53a2d7a359e8e7e68de393c9.png" alt=""></p><h2 id="参考模型-Reference-Models"><a href="#参考模型-Reference-Models" class="headerlink" title="参考模型/Reference Models"></a>参考模型/Reference Models</h2><ul><li>The OSI Reference Model  </li><li>The TCP/IP Reference Model  </li><li>A Comparison of OSI and TCP/IP  </li><li>A Critique of the OSI Model and Protocols  </li><li>A Critique of the TCP/IP Reference Model  </li></ul><h3 id="OSI-RM-开放系统互连参考模型"><a href="#OSI-RM-开放系统互连参考模型" class="headerlink" title="OSI/RM 开放系统互连参考模型"></a>OSI/RM 开放系统互连参考模型</h3><p><img src="/2017/12/CN-Chapter-One/9f16f949e19cfbd2358b6bd252b289cc.png" alt=""></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul><li>确保发送端发送的数据和接收端解析出的数据一致  </li><li>表示1，0</li><li>传输同步性(Transmission simultaneous *第二章)</li><li>连接建立和结束</li><li>网络连接器</li><li>物理传输介质</li></ul><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>对传输错误的处理（屏蔽）使得其上层网络层看不到传输错误 （*第三章）  </p><blockquote><p>  发送端将数据分成数据帧，再按顺序传输这些帧<br>  返回确认帧（Acknowledgment frame）</p></blockquote><p>流量控制    </p><blockquote><p>  避免一个快速发送方用数据淹没一个慢速接收方</p></blockquote><p>广播式网络：共享信道访问控制</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>将分组packets从源端路由到目标端</li><li>拥塞（congestion）处理</li><li>服务质量</li><li>异构（Heterogeneous）网络互联</li></ul><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul><li>接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，确保数据单元正确地到达另一端</li><li>高效率地以上下隔离的方式完成</li><li>决定了向会话层，因而是实际的最终网络用户提供哪种类型的服务</li><li>真正的端到端的层</li><li>屏蔽网络层属性 用户不关心网络层结构</li></ul><p><em>第1~3层是链式连接的，而第4~7层是端到端的</em></p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>允许不同机器上的用户建立对话对话控制令牌管理同步功能</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>语法，句义（加密等）                                 |</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>包含了用户通常用到的各种各样的协议<br>&emsp;&emsp;HTTP等</p><h3 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a><strong>TCP/IP</strong>的体系结构</h3><p><img src="/2017/12/CN-Chapter-One/7dcfd2fccdfe87238e17455575b223e7.png" alt=""></p><h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>链路必须完成什么功能才能满足无连接的互联网络层需求<br>（不是真正意义上的一个层，而是主机与传输线路之间的一个接口）</p><h4 id="互联网层"><a href="#互联网层" class="headerlink" title="互联网层"></a>互联网层</h4><ul><li>分组到达接收端的顺序可能不一致（无连接服务）</li><li>将分组独立进行路由到达目标端</li><li>IP/ICMP</li><li><p>…</p><h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4></li><li><p>端到端协议TCP UDP</p></li><li>TCP Transmission Control Protocol 面向连接，可靠服务</li><li>UDP User Datagram Protocol 无连接，不可靠服务</li></ul><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><p>包含所需的任何会话和表示功能</p><h4 id="主机-网络层"><a href="#主机-网络层" class="headerlink" title="主机-网络层"></a>主机-网络层</h4><p>不是独立层</p><h3 id="OSI与TCP-IP比较"><a href="#OSI与TCP-IP比较" class="headerlink" title="OSI与TCP/IP比较"></a>OSI与TCP/IP比较</h3><h4 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a><em>相似点</em></h4><ul><li>基于相似的概念——独立协议的堆积</li><li>分层的功能几乎相似</li></ul><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><em>不同点</em>：</h4><h5 id="OSI："><a href="#OSI：" class="headerlink" title="OSI："></a>OSI：</h5><ul><li>对服务，接口和协议有良好定义</li><li>与面向对象（OO）的编程思想相吻合协议隐藏性更好</li></ul><h5 id="TCP："><a href="#TCP：" class="headerlink" title="TCP："></a>TCP：</h5><ul><li>协议为先；模型只是协议的一个描述。然而模型对其他的协议都不大吻合</li><li>TCP/IP模型并未清晰地区分服务，接口和协议*</li></ul><h3 id="本书所采用的模型是一个混合模型："><a href="#本书所采用的模型是一个混合模型：" class="headerlink" title="本书所采用的模型是一个混合模型：*"></a><em>本书所采用的模型是一个混合模型：*</em></h3><p><img src="/2017/12/CN-Chapter-One/55856abedeef5583a6a866742f3e074d.png" alt=""></p><h2 id="网络实例"><a href="#网络实例" class="headerlink" title="网络实例"></a>网络实例</h2><h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h3><p><img src="/2017/12/CN-Chapter-One/90e42b60cfc67b1810895d9bbf6599d3.png" alt=""></p><h3 id="3G移动电话网络"><a href="#3G移动电话网络" class="headerlink" title="3G移动电话网络"></a>3G移动电话网络</h3><p><img src="/2017/12/CN-Chapter-One/5873700ee16b05a4ca83e25cbe4e3c16.png" alt=""></p><p>由于3G网络的频谱稀缺，导致网络之间的干扰成为一个严重问题</p><p>解决问题的一个方法是将基站分布成为蜂窝状（每个相邻区域使用不同频率段）：</p><p><img src="/2017/12/CN-Chapter-One/2be7d01ba196e3fe7cf610f4f92ca139.png" alt=""></p><p>与因特网的不同点：</p><ol><li>体系结构：UMTS</li><li>移动性：当用户移动出一个蜂窝基站的覆盖范围进入到另一个蜂窝基站的覆盖范围时，数据流必须从旧蜂窝基站重新路由到新蜂窝基站。（handover, handoff）<h3 id="无线网络：802-11"><a href="#无线网络：802-11" class="headerlink" title="无线网络：802.11"></a>无线网络：802.11</h3></li></ol><p>802.11/(WiFi)的体系架构</p><p><img src="/2017/12/CN-Chapter-One/b52b3b0f3cf9daff54eb40fb5ec58f6b.png" alt=""></p><p>*RFID与传感器网络</p><h2 id="网络标准化"><a href="#网络标准化" class="headerlink" title="网络标准化"></a>网络标准化</h2><p>ITU，ISO，IETF，IEEE<br>ITU（International Telecommunication Union）  </p><p><img src="/2017/12/CN-Chapter-One/e7590e45b75f746a496b655aed468372.png" alt=""></p><p><img src="/2017/12/CN-Chapter-One/c6562e1759e47aadeb80b9700723fc5f.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月13日&lt;br&gt;08:08&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="Computer_Network" scheme="https://blog.kimisecond.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 进程同步/Process Synchronization 第六章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Six/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Six/</id>
    <published>2017-12-20T23:29:01.000Z</published>
    <updated>2018-03-15T11:55:55.480Z</updated>
    
    <content type="html"><![CDATA[<p>2017年10月24日<br>09:53</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i2hOYPL38sWg1Ns-" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i2nvmSXVMUTlMht3" target="_blank" rel="noopener">(pdf)</a></strong></p><p><strong>进程同步</strong></p><ul><li>并发进程之间相互合作、互相约束  </li><li>利用私用信号量实现</li></ul><p><img src="/2017/12/OS_Concept_Chapter_Six/b6e1b53a88e54edd4dafc15e52a4468c.png" alt="． P4 进 程 等 待 P2 和 P3 进 程 的 结 果 ． P4 进 程 和 P2 、 P3 之 间 要 同 步 协 调 0 "></p><p><strong>进程互斥(exclusion)</strong></p><ul><li>并发进程之间互相竞争临界资源的排他性关系  </li><li>利用公用信号量实现互斥  </li><li>互斥源于资源共享，是进程之间的制约关系</li></ul><p><img src="/2017/12/OS_Concept_Chapter_Six/2ae76fdd4904ce6ceb1e51296fec8db6.png" alt="0 例 如 丫 PI 使 用 打 印 机 ， P2 就 不 能 使 用 "></p><p><img src="/2017/12/OS_Concept_Chapter_Six/f55a642aea69656e2ca83887330998ae.png" alt="． 0 、 打 印 机 等 结 果 被 PI 一 P8 所 有 进 行 使 用 ， 需 要 排 他 使 用 一 个 使 用 时 ， 其 它 进 程 不 能 用 等 结 果 PI 和 P2 约 束 P3 、 P4 和 P5 之 日 一 束 匕 进 程 利 用 私 用 信 号 量 使 用 公 用 信 号 量 等 结 果 P6 、 P7 和 P8 之 间 束 及 其 它 、 利 用 私 用 信 号 量 公 用 信 号 量 、 私 用 信 号 量 ： 都 是 针 对 全 部 8 个 进 程 而 言 "></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a><strong>Background</strong></h2><p><em>Concurrent access</em> to shared data may result in <em>data inconsistency</em><br>Maintaining data consistency requires mechanisms to <em>ensure the orderly execution of cooperating processes</em>  </p><p><img src="/2017/12/OS_Concept_Chapter_Six/be5ba0148b905da6601622ad32a5342b.png" alt=""></p><blockquote><p>  生产者进程—->buffer—->消费者进程</p></blockquote><p><strong>保持数据稳定性</strong></p><ul><li>维护一个整数计数器，追踪满缓存数量  </li><li>初始设为0  </li><li>被<em>生产者</em>增加，每提供一个新缓存+1  </li><li>被<em>消费者</em>减少</li></ul><p>由于count没有在生产者和消费者之间同步，生产者和消费者进程会交替执行，而count一直被调去却未返回维护，导致生产者和消费者的寄存器中<em>代表count的寄存器值不同</em></p><p>竞争条件  </p><ul><li>多个进程并发访问和操作统一数据  </li><li>执行结果与访问发生的特定顺序有关</li></ul><p>为避免，需要确保一段时间内只有一个进程可以操作变量，所以需要<em>进程之间的同步与协调</em></p><h2 id="临界区问题Critical-Section-进程互斥"><a href="#临界区问题Critical-Section-进程互斥" class="headerlink" title="临界区问题Critical Section/进程互斥"></a><strong>临界区问题Critical Section/进程互斥</strong></h2><p>临界区：进程访问临界资源的那段代码</p><p>解决互斥方法：</p><ul><li>软件  </li><li>硬件</li></ul><p><strong>临界资源</strong></p><ul><li>又被称为互斥资源(exclusive resources)  </li><li>这些系统资源每次只能被一个进程使用</li></ul><p><strong>临界区</strong></p><ul><li>又被称为互斥区(exclusive section)  </li><li>访问临界资源的代码段</li></ul><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>每个进程必须在进入临界区之前寻求许可 （特别是在抢占式内核中，实现方式很有挑战性）</p><ul><li>进入区entry section  </li><li>退出区exit section  </li><li>代码中的其余部分remainder section</li></ul><p><img src="/2017/12/OS_Concept_Chapter_Six/697682e4fadc7ef3f83d7cf834fe640f.png" alt=""></p><h3 id="临界区的访问规则"><a href="#临界区的访问规则" class="headerlink" title="临界区的访问规则"></a>临界区的访问规则</h3><h4 id="互斥-mutual-exclusion"><a href="#互斥-mutual-exclusion" class="headerlink" title="互斥/mutual exclusion"></a>互斥/mutual exclusion</h4><p>当进程i正在临界区，其他进程都不能访问他们的临界区</p><h4 id="前进Progress"><a href="#前进Progress" class="headerlink" title="前进Progress"></a>前进Progress</h4><p>如果</p><blockquote><p>  无进程在临界区<br>  存在进程希望进入临界区</p></blockquote><p>那么，选定的进程进入临界区  </p><blockquote><p>  进程不能被无限推迟</p></blockquote><h4 id="有限等待Bounded-Waiting"><a href="#有限等待Bounded-Waiting" class="headerlink" title="有限等待Bounded Waiting"></a>有限等待Bounded Waiting</h4><p>不会有饥饿现象</p><p><strong>有空让进，无空等待，多中择一，有限等待，让权等待</strong></p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul><li>在进入区检查设置一些标志  </li><li>进入区循环检查进行等待  </li><li>退出区修改标志</li></ul><p>问题：设置什么标志，如何检查标志</p><h3 id="算法1：单标志位"><a href="#算法1：单标志位" class="headerlink" title="算法1：单标志位"></a>算法1：单标志位</h3><ul><li>设置变量turn  </li><li>进循环前查值（空等待）  </li><li>进循环后改变值</li></ul><p><img src="/2017/12/OS_Concept_Chapter_Six/c8f3dd4cdac99f6f652906d508383637.png" alt=""></p><p>顺序：1，2，1，2，1，2…</p><p>缺点：<br>&emsp;&emsp;进程强制轮流进入临界区，容易造成资源利用不充分</p><p>e.g:<br>&emsp;&emsp;Pi让出临界区之后，Pj使用临界区之前，Pi不可能再次使用临界区</p><h3 id="算法2：双标志位（先检查）"><a href="#算法2：双标志位（先检查）" class="headerlink" title="算法2：双标志位（先检查）"></a>算法2：双标志位（先检查）</h3><p>标志数组flag[]：描述进程是否在临界区，初值均为FALSE</p><p>先检查，后修改</p><p><img src="/2017/12/OS_Concept_Chapter_Six/8653cb02aa3de96612dbfbb83a020394.png" alt=""></p><p>解决了顺序固定的问题</p><p>缺点：可能同时进入临界区<br>&emsp;&emsp;检查对方flag之后和切换自己flag之前有一段时间，结果都检查通过。</p><p><em>检查和修改操作不能连续进行</em></p><h3 id="算法3：双标志（先修改）"><a href="#算法3：双标志（先修改）" class="headerlink" title="算法3：双标志（先修改）"></a>算法3：双标志（先修改）</h3><p><img src="/2017/12/OS_Concept_Chapter_Six/566a220578be3a3c49a1779771444f0b.png" alt=""></p><p>缺点：可能都无法进入临界区</p><h3 id="实例：Peterson算法"><a href="#实例：Peterson算法" class="headerlink" title="实例：Peterson算法"></a>实例：Peterson算法</h3><p>将1与3相结合</p><p>维护两个变量，turn和flag[]</p><p><img src="/2017/12/OS_Concept_Chapter_Six/e496d0bef66a8f2b90d74bb30d75b862.png" alt=""></p><p>互斥被保护，进程申请可以通过，有限等待也得以满足</p><p>缺点：</p><ul><li>忙等待  </li><li>实现复杂，需要比较高的编程技巧（本实例仅提供双进程方案）</li></ul><h2 id="Process-Synchronization"><a href="#Process-Synchronization" class="headerlink" title="Process Synchronization"></a><strong>Process Synchronization</strong></h2><p>同步机制<br>&emsp;&emsp;从进程管理者的角度来处理互斥同步问题</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>表示资源的实体，是一个与队列有关的整型变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore</span><br><span class="line">&#123;  </span><br><span class="line">    int value;  </span><br><span class="line">    pointer_PCB queue;   </span><br><span class="line">    //阻塞在该信号量的各个进程的标识  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>操作：初始化，P/V原语(Wait &amp; signal)<br>不受进程调度的打断<br>公用信号量初值为1<br>私用初值为0或某个正整数  </p><p>信号量取值</p><ul><li>非负：空闲资源数  </li><li>负：等待临界区进程数</li></ul><h3 id="P-V操作"><a href="#P-V操作" class="headerlink" title="P/V操作"></a>P/V操作</h3><h4 id="P操作P-S"><a href="#P操作P-S" class="headerlink" title="P操作P(S)"></a>P操作P(S)</h4><p>申请分配一个单位的资源</p><p><img src="/2017/12/OS_Concept_Chapter_Six/0b439cc1cb2c1edd1a6299d6bd5ae830.png" alt=""></p><h4 id="V操作V-S"><a href="#V操作V-S" class="headerlink" title="V操作V(S)"></a>V操作V(S)</h4><p>释放一个单位的资源</p><p><img src="/2017/12/OS_Concept_Chapter_Six/0b9563dd49d1963bfca404fc7d2f8b88.png" alt=""></p><h4 id="关于…"><a href="#关于…" class="headerlink" title="关于…"></a>关于…</h4><p><img src="/2017/12/OS_Concept_Chapter_Six/c29d3ec828681545008d9d243222402e.png" alt=""></p><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li>简单，表达能力强</li><li>不够安全，使用不当会出现死锁</li><li>遇到复杂同步互斥问题实现比较难</li></ul><h4 id="应用：实现互斥"><a href="#应用：实现互斥" class="headerlink" title="应用：实现互斥"></a>应用：实现互斥</h4><p>引入mutex信号量，初值为1</p><p><img src="/2017/12/OS_Concept_Chapter_Six/7c81483c2b963ae836cd73459a1ddc1f.png" alt=""></p><p>同步：PV分别位于两个不同进程<br>互斥：在一个进程中</p><h5 id="例1：读者、写者问题"><a href="#例1：读者、写者问题" class="headerlink" title="例1：读者、写者问题"></a>例1：读者、写者问题</h5><p><img src="/2017/12/OS_Concept_Chapter_Six/ea65d5e146a63b269b656ab27920f0d9.png" alt=""></p><p><img src="/2017/12/OS_Concept_Chapter_Six/9523c91a6141853ca5f2936f640893c6.png" alt=""></p><h5 id="例2：生产者、消费者问题"><a href="#例2：生产者、消费者问题" class="headerlink" title="例2：生产者、消费者问题"></a>例2：生产者、消费者问题</h5><p><img src="/2017/12/OS_Concept_Chapter_Six/fbc85bf4fed8d4fa7eb63b38bfda848a.png" alt=""></p><p><strong>先检查资源数目，再检查互斥（<em>避免死锁</em>）</strong></p><p><img src="/2017/12/OS_Concept_Chapter_Six/cdbabb7fe9281bbeb224ac619b43e2b8.png" alt=""></p><p>所有访问缓冲区的申请互斥<br>生产者消费者同步</p><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><p><img src="/2017/12/OS_Concept_Chapter_Six/1169ed130434f82d6fc9bf45c3bda0f4.png" alt=""> </p><p><img src="/2017/12/OS_Concept_Chapter_Six/28a4faf7e40b3bfdfb3476ce1c98bb9e.png" alt=""></p><p><img src="/2017/12/OS_Concept_Chapter_Six/25b17fb2f4d66dcd9f537c721915aa1e.png" alt=""></p><h5 id="Sleeping-Barber"><a href="#Sleeping-Barber" class="headerlink" title="Sleeping Barber"></a>Sleeping Barber</h5><p><img src="/2017/12/OS_Concept_Chapter_Six/98f754666203f43ca962981708746a9f.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年10月24日&lt;br&gt;09:53&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 CPU调度/CPU Scheduling 第五章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Five/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Five/</id>
    <published>2017-12-18T12:19:12.000Z</published>
    <updated>2018-03-15T11:55:17.964Z</updated>
    
    <content type="html"><![CDATA[<p>2017年10月12日<br>08:01</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i1GXy0MAHwPiEaM2" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i1Jvb6itFn4XUf_B" target="_blank" rel="noopener">(pdf)</a></strong></p><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a><strong>Basic Concepts</strong></h2><p>Maximum CPU utilization obtained with multiprogramming</p><h3 id="CPU-I-O-Burst-Cycle（突发时间）"><a href="#CPU-I-O-Burst-Cycle（突发时间）" class="headerlink" title="CPU-I/O Burst Cycle（突发时间）"></a>CPU-I/O Burst Cycle（突发时间）</h3><p>Process execution consists of a cycle of <em>CPU execution</em> and I/O wait</p><p><img src="/2017/12/OS_Concept_Chapter_Five/media/c0735cb7a208e52e5bfb798015837059.png" alt=""></p><ul><li>I/O bound: I/O↑ CPU↓  </li><li>CPU bound：I/O↓ CPU↑</li></ul><h3 id="进程调度的关键"><a href="#进程调度的关键" class="headerlink" title="进程调度的关键"></a>进程调度的关键</h3><p>在长期调度中协调I/O bound与CPU bound</p><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>Selects from among the processes in memory that are ready to execute<br>Allocates the CPU to one of them</p><p><a href="http://kimisecond.com/2017/12/OS_Concept_Chapter_Three/" target="_blank" rel="noopener">调度<br>Review</a></p><h4 id="Non-preemptive（非抢占方式）"><a href="#Non-preemptive（非抢占方式）" class="headerlink" title="Non-preemptive（非抢占方式）"></a>Non-preemptive（非抢占方式）</h4><p>Scheduling take place when a process:  </p><ul><li>Terminates  </li><li>Switches from running to waiting(I/O requests)  </li><li>Some kind of primitive is executed in process communication or<br>synchronization, such as Block primitive（阻塞原语）,Wakeup<br>primitives（唤醒原语）</li></ul><h4 id="Preemptive（抢占方式）"><a href="#Preemptive（抢占方式）" class="headerlink" title="Preemptive（抢占方式）"></a>Preemptive（抢占方式）</h4><p>允许打断正在运行中的进程</p><p>Scheduling take place when a process:  </p><ul><li>Running to ready  </li><li>Waiting to ready</li></ul><p>Causes</p><ul><li>Access to Shared data  </li><li>While in kernel mode  </li><li>Interrupts occurring during crucial OS activities</li></ul><h3 id="Dispatcher（进程调度程序）"><a href="#Dispatcher（进程调度程序）" class="headerlink" title="Dispatcher（进程调度程序）"></a>Dispatcher（进程调度程序）</h3><p>将cpu的控制权分配给process</p><p>Tasks:  </p><ul><li>Switching context  </li><li>To user mode  </li><li>Jumping to the proper location in their user program to restart that program</li></ul><p>Dispatch latency</p><ul><li>Stop one process and start another running</li></ul><h2 id="Scheduling-Criteria"><a href="#Scheduling-Criteria" class="headerlink" title="Scheduling Criteria"></a><strong>Scheduling Criteria</strong></h2><h3 id="General-Criteria"><a href="#General-Criteria" class="headerlink" title="General Criteria"></a>General Criteria</h3><ul><li>CPU utilization</li><li><p>Throughput</p><blockquote><p>  Number of Processes that are completed per time unit</p></blockquote></li><li><p>Turnaround time  </p><p>Time spent waiting to</p><blockquote><p>  Get into memory<br>  Waiting in the ready queue<br>  Executing on the CPU<br>  Doing I/O  </p></blockquote><p><em>Long-term Scheduling</em></p></li><li><p>Waiting time</p></li></ul><blockquote><p>  Time that a process spends waiting in the ready queue</p></blockquote><ul><li>Response time</li></ul><blockquote><p>  From the submission of a request until the first response is produced</p></blockquote><p><em>Interactive system</em></p><h3 id="Optimization-Criteria"><a href="#Optimization-Criteria" class="headerlink" title="Optimization Criteria"></a>Optimization Criteria</h3><ul><li>Max CPU utilization   </li><li>Max throughput   </li><li>Min turnaround time（轮转时间）   </li><li>Min waiting time   </li><li>Min response time   </li></ul><h2 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms*"></a><strong>Scheduling Algorithms*</strong></h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p>First-come, first-served<br>Average waiting time is often quite long.<br>适合处理长调度，有利于长作业<br>Convoy effect（护航效应）<br>&emsp;&emsp;short process behind long process</p><h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p>Shortest-job-first（SJF）（非抢占）<br>对于抢占，非抢占  </p><ul><li>抢占效果更优  </li><li>抢占：SRTF</li></ul><p>Optimal - gives minimum average waiting time for a given set of processes   </p><ul><li>The difficulty is knowing the length of the next CPU request   </li><li>Could ask the user</li></ul><h4 id="预测下一个CPU-burst-time"><a href="#预测下一个CPU-burst-time" class="headerlink" title="预测下一个CPU burst time"></a>预测下一个CPU burst time</h4><p>指数平均</p><p><img src="/2017/12/OS_Concept_Chapter_Five/media/3496d68ec121e1a5ed313ca848a61d72.png" alt=""></p><p>Tn= actual length of nth CPU burst</p><p>α->0<br>&emsp;&emsp;History not count</p><p>α->1<br>&emsp;&emsp;Only the actual last CPU burst counts  </p><p>算法易于实现，但是效率不高</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>忽略作业等待时间  </li><li>会出现饥饿现象（大作业很难执行）  </li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>SJF的平均作业周转时间比FCFS要小，所以它的调度性能比FCFS好</p><h4 id="SJF调度算法问题"><a href="#SJF调度算法问题" class="headerlink" title="SJF调度算法问题"></a>SJF调度算法问题</h4><p>需要知道作业所需运行时间，否则调度就没有依据，不可能精确计算出运行时间<br>（即难点为预测下一个作业时间片长度）</p><h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p>数字越小，优先级越高</p><p>SJF: Priority is the predicted next CPU burst time</p><p>Starvation:<br>&emsp;&emsp;Low priority processes may never execute</p><p>Solution:<br>动态调整优先级，Aging —- as time progresses increase the priority of the process</p><p>静态优先级</p><p>动态优先级</p><p>高响应比优先调度HRRF<br>响应比：<strong>作业等待时间与运行时间比值</strong><br><strong>响应比=（等待时间+要求服务时间）/要求服务时间</strong></p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>响应比计算增加了系统开销  </li></ul><h3 id="Round-Robin-Scheduling-轮转算法"><a href="#Round-Robin-Scheduling-轮转算法" class="headerlink" title="Round-Robin Scheduling 轮转算法"></a>Round-Robin Scheduling 轮转算法</h3><p>将cpu时间分为确定的时间片，每个作业不得超过这个固定时间<br>若单个任务超过这个时间，则按时间片划分，按FIFO处理（ready queue）<br>时间片不能太长，不然会退化成FCFS<br>时间片不能太短  </p><ul><li>负载严重     </li><li>吞吐量受影响  </li></ul><p>平衡短作业的性能和长作业的吞吐量</p><ul><li>10-100ms  </li><li>上下文切换：0.1-1ms  </li><li>1%的负载是上下文切换   </li></ul><h3 id="Multilevel-Queue-Scheduling"><a href="#Multilevel-Queue-Scheduling" class="headerlink" title="Multilevel Queue Scheduling"></a>Multilevel Queue Scheduling</h3><p>每个队列有自己的调度算法   </p><h4 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h4><ul><li>队列之间必须有调度，采用固定优先级抢占调度  </li><li>进程可以在队列之间移动，借助aging实现</li></ul><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><ul><li>分为前台foreground process和后台background process  </li><li>前台交互，后台批处理  </li><li>80%(time) foreground RR  </li><li>20% background FCFS  </li></ul><h4 id="Feedback-Queue"><a href="#Feedback-Queue" class="headerlink" title="Feedback Queue"></a>Feedback Queue</h4><ul><li>根据时间推移，动态改变作业所在的队列  </li><li>Number of queues   </li><li>Scheduling algorithms for each queue  </li><li>Method used to determine when to upgrade/demote a process  </li><li>Method used to determine which queue a process will enter when that process needs service  </li></ul><h3 id="Algorithm-for-a-particular-system"><a href="#Algorithm-for-a-particular-system" class="headerlink" title="Algorithm for a particular system"></a>Algorithm for a particular system</h3><h4 id="Multiple-Processor-Scheduling"><a href="#Multiple-Processor-Scheduling" class="headerlink" title="Multiple-Processor Scheduling"></a>Multiple-Processor Scheduling</h4><p>SMP / Asymmetric multiprocessing</p><p>Load Balancing  </p><ul><li><p>SMP: keep the workload balances<br>one or more processors sit idle, others high workload(bad)</p><p>Pull  </p><ul><li>空闲cpu从繁忙cpu中获取一个进程  </li></ul><p>Push  </p><ul><li>繁忙cpu队列把一个进程推送到空闲CPU队列中</li></ul></li></ul><h4 id="Real-Time-Scheduling"><a href="#Real-Time-Scheduling" class="headerlink" title="Real-Time Scheduling"></a>Real-Time Scheduling</h4><h5 id="硬实时"><a href="#硬实时" class="headerlink" title="硬实时"></a>硬实时</h5><p>硬件实现</p><ul><li>CPU运算周期按照原先设定的标准（比如Time Slice）  </li><li>或按照某些硬件优先权分配  </li></ul><h5 id="软实时"><a href="#软实时" class="headerlink" title="软实时"></a>软实时</h5><ul><li>对非实时的操作系统进行某些改动，达到近乎实时的效果   </li><li>用一个专门的软件部件，达到快速反应   </li><li>这个进程的优先级相当高</li></ul><h2 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a><strong>Thread Scheduling</strong></h2><h3 id="Local-Scheduling"><a href="#Local-Scheduling" class="headerlink" title="Local Scheduling"></a>Local Scheduling</h3><p>How the threads library decides which thread to put onto an available LWP</p><h3 id="Global-Scheduling"><a href="#Global-Scheduling" class="headerlink" title="Global Scheduling"></a>Global Scheduling</h3><p>How the kernel decides which kernel thread to run next</p><h3 id="PCS-amp-SCS"><a href="#PCS-amp-SCS" class="headerlink" title="PCS&amp;SCS"></a>PCS&amp;SCS</h3><ul><li>PCS进程竞争范围  </li><li>SCS系统竞争范围  </li><li>先PCS，再通过LWP放到SCS，再放到CPU</li></ul><h3 id="Solaris-2"><a href="#Solaris-2" class="headerlink" title="Solaris 2"></a>Solaris 2</h3><ul><li>Real time  </li><li>System  </li><li>Interactive &amp; time sharing</li></ul><h2 id="Scheduling-evaluation"><a href="#Scheduling-evaluation" class="headerlink" title="Scheduling evaluation"></a><strong>Scheduling evaluation</strong></h2><p>Deterministic modeling</p><p>Queuing models</p><p>Implementation/simulation</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年10月12日&lt;br&gt;08:01&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 线程/Thread 第四章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Four/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Four/</id>
    <published>2017-12-18T11:26:55.000Z</published>
    <updated>2018-03-15T11:55:47.753Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月27日<br>17:44</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2i0_m7xPdflGoL4dE" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2i1ACw7u8YJsB8hbN" target="_blank" rel="noopener">(pdf)</a></strong></p><p>提高系统运行效率<br>相比进程更加轻量化</p><h2 id="对于任务切换："><a href="#对于任务切换：" class="headerlink" title="对于任务切换："></a>对于任务切换：</h2><p>每次分配资源越多越好，避免频繁分配<br>每次调度的基本单位越小越好</p><p><img src="/2017/12/OS_Concept_Chapter_Four/9819bd0f7c87b83f532be87627076fbe.png" alt=""></p><p>对于上图，显然B效率更高</p><h2 id="Main-idea"><a href="#Main-idea" class="headerlink" title="Main idea"></a>Main idea</h2><p>Separate the allocation and scheduling of the process resource<br>The concept of threads is introduced.</p><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>一次性分配充足资源——避免频繁分配资源<br>降低调度单位，提高并发性</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>系统开销<br>切换线程比进程所需时间少很多</p><p>通讯  </p><blockquote><p>  进程间通讯费时且不便利<br>  统一进程下线程交换信息高效便捷</p></blockquote><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>线程</p><ul><li>有时称轻量进程</li><li>进程中的一个运行实体</li><li>是一个CPU调度单位</li><li>资源的拥有者是进程或称任务</li><li>可由内核控制，也可由用户控制<br>也描述为：  <blockquote><p>  <em>进程的执行体</em>、<em>一个执行单元</em>、进程内的一个可调度实体等。</p></blockquote></li></ul><p><img src="/2017/12/OS_Concept_Chapter_Four/997766cc3de4ef99e55fbef772469075.png" alt=""></p><p>基本不拥有系统资源，存取所在进程的内存和其他资源<br>只包含一些如程序计数器，寄存器和一组栈<br>TCB（线程控制块）  </p><blockquote><p>  <strong>不运行时保存上下文</strong></p></blockquote><h3 id="TCB："><a href="#TCB：" class="headerlink" title="TCB："></a>TCB：</h3><ul><li>CPU执行状态：寄存器，PC，堆栈指针  </li><li>调度信息  </li><li>统计信息  </li><li>队列指针</li></ul><p><img src="/2017/12/OS_Concept_Chapter_Four/5dc18747913ebbf9c47166c705a3c4d1.png" alt=""></p><h2 id="多线程实现机制"><a href="#多线程实现机制" class="headerlink" title="多线程实现机制"></a>多线程实现机制</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><ul><li>通过库函数直接编程，对程序员友好(Pthread)  </li><li>仅存在于用户空间中  </li><li>许多功能无需系统调用，切换无需内核管理，切换规则简单</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>不调用内核  </li><li>调度由应用程序特定：可以选择最好的算法  </li><li>可以运行在任何操作系统上（只需线程库）（可移植性）</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>许多系统调用形成阻塞  </li><li>统一进程中两个线程不能同时运行于两个处理器上   </li><li>只适合单CPU</li></ul><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可调度一个进程中的多个线程，可同时再多核cpu上运行  </li><li>其中一个阻塞不影响其他线程  </li><li>内核本身可以以线程方式实现多处理器的处理功能，内核可以同时调度同一进程的多个线程   </li><li>阻塞是在线程一级完成  </li><li>内核例程是多线程的  <h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>线程调度在内核态下运行，应用程序在用户态下运行  </li><li>控制过程中需要内核态和用户态的两次模式切换   </li><li>同一进程内的线程切换调用内核，导致速度下降   </li></ul><h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><ul><li>一般在不支持内核级进程的机器上运行  </li><li>线程管理在用户空间完成，所以它的效率比较高。  </li><li>如果一个线程调用了导致阻塞的系统调用的话，那么将阻塞整个进程。  <h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4></li><li>保持了更好的并发性   </li><li>创建内核线程的开销会加重应用程序的负担，所以这种模型的大多数实现都要限制系统支持的线程数量。  <h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3></li><li>集合了上两者的优点  </li><li>然而对操作系统的实现上会比较复杂困难  </li><li>多对多模型将用户级线程多路映射到内核线程，映射的内核线程数量可以与之相等或更少。  </li><li>多对一模型允许开发者创建任意多个用户线程。但是，因为内核一次只能调度一个线程，所以并不能获得真正的并行性。</li></ul><h3 id="轻量级进程（LWP）"><a href="#轻量级进程（LWP）" class="headerlink" title="轻量级进程（LWP）"></a>轻量级进程（LWP）</h3><p>是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源</p><p>与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；</p><p>LWP的一个重要作用是提供了一个用户级线程实现的中间系统。LWP可以通过系统调用获得内核提供的服务，因此，当一个用户级线程运行时，只需要将它连接到一个LWP上便可以具有内核支持线程的所有属性。</p><h3 id="进程库"><a href="#进程库" class="headerlink" title="进程库"></a>进程库</h3><p>给程序员提供API来创建管理线程</p><p>有两种主要实现方式</p><blockquote><p>  把库完全放在用户空间</p><p>  OS支持的内核级库</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月27日&lt;br&gt;17:44&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 进程/Process 第三章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Three/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Three/</id>
    <published>2017-12-14T10:25:06.000Z</published>
    <updated>2018-03-15T11:56:03.273Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月20日<br>13:56</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2imlj2W8TmfdSAxKe" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2imjpU2cQvQqMXLre" target="_blank" rel="noopener">(pdf)</a></strong></p><p><strong>Notion of process</strong><br><strong>Various features of processes</strong><br><strong>communication</strong></p><h2 id="Main-Problems"><a href="#Main-Problems" class="headerlink" title="Main Problems"></a>Main Problems</h2><p><strong>1.    process vs. program</strong><br><strong>2.    pcb 分配资源 初始化pcb</strong><br><strong>3.    process fork()</strong>   </p><ul><li><strong>创建，删除 进程树</strong>  </li><li><strong>状态图</strong>   </li><li><strong>动作/操作</strong></li></ul><p><strong>4.    Scheduling:</strong>  </p><ul><li><strong>Short term</strong>  </li><li><strong>Medium term</strong>  </li><li><strong>Long term</strong></li></ul><p><strong>5.    Communication</strong><br><strong>6.    Process context</strong></p><h2 id="Process-Concept"><a href="#Process-Concept" class="headerlink" title="Process Concept"></a><strong>Process Concept</strong></h2><blockquote><p>  Process Defintion<br>  Process State<br>  Process Control Block (PCB)  </p></blockquote><h3 id="Problems-for-Process-Management"><a href="#Problems-for-Process-Management" class="headerlink" title="Problems for Process Management"></a><em>Problems for Process Management</em></h3><p><em>Dispatch CPU</em><br><em>Allocate resource (deadlock hungry)</em>     <em>Implement the process communication</em>   </p><h3 id="Process-Definition"><a href="#Process-Definition" class="headerlink" title="Process Definition"></a><em>Process Definition</em></h3><blockquote><p>  Process —- a program in execution; process execution must progress in sequential fashion<br>  一个具有独立功能的程序在一个数据集合上的一次动态执行过程</p></blockquote><h4 id="Process-includes"><a href="#Process-includes" class="headerlink" title="Process includes"></a><em>Process includes</em></h4><ul><li>Program counter  </li><li>Stack  </li><li>Data section  </li><li>*heap  <h4 id="Process-in-Memory"><a href="#Process-in-Memory" class="headerlink" title="Process in Memory"></a>Process in Memory</h4><img src="/2017/12/OS_Concept_Chapter_Three/388ad9e85e2d1984da645e4bdbb93634.png" alt=""></li></ul><h4 id="一些进程概念和特性："><a href="#一些进程概念和特性：" class="headerlink" title="一些进程概念和特性："></a>一些进程概念和特性：</h4><ul><li>真实描述任务的<em>并发执行</em>  </li><li>进程由<em>程序</em>和<em>数据</em>两部分组成  </li><li>进程是<em>动态的</em>  </li><li>一个程序对应<em>多个进程</em>  </li><li>进程具有<em>创建其它进程</em>的功能  </li></ul><h4 id="进程特征："><a href="#进程特征：" class="headerlink" title="进程特征："></a>进程特征：</h4><ul><li>结构特征：程序段、数据段、PCB  </li><li>动态性：程序的一次执行过程  </li><li>并发性：多个进程同存于内存中，在一段时间中同时运行  </li><li>独立性：进程独立运行、独立分配资源的基本单位  </li><li>异步性：独立、不可预知  </li><li>交互性：需要交互  <h3 id="Process-State"><a href="#Process-State" class="headerlink" title="Process State"></a><em>Process State</em></h3></li></ul><blockquote></blockquote><p><img src="/2017/12/OS_Concept_Chapter_Three/acad6a06f2f8b9985043cee67e1ce35c.png" alt=""></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><p><strong>进程和程序的联系与区别</strong></p><h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block)"></a><em>PCB(Process Control Block)</em></h3><h4 id="Content-Brief"><a href="#Content-Brief" class="headerlink" title="Content(Brief)"></a>Content(Brief)</h4><ul><li>Process state  </li><li>Program counter  </li><li>CPU registers  </li><li>CPU scheduling information  </li><li>Memory-management information  </li><li>Accounting information  </li><li>I/O status information  </li></ul><h4 id="表本身…"><a href="#表本身…" class="headerlink" title="表本身…"></a>表本身…</h4><p>系统把PCB组织在一起，并放在内存固定区域，构成PCB表  </p><ul><li>链表  </li><li>索引表  </li></ul><p>PCB表的大小决定了系统中<em>最多可同时存在的进程个数</em>，称为系统的并发度</p><h4 id="PCB组织方式-—-链接方式"><a href="#PCB组织方式-—-链接方式" class="headerlink" title="PCB组织方式 — 链接方式"></a>PCB组织方式 — 链接方式</h4><p><img src="/2017/12/OS_Concept_Chapter_Three/4308232d45a3a8285f09172e3e3379dc.png" alt=""></p><h4 id="PCB组织方式-—-索引方式"><a href="#PCB组织方式-—-索引方式" class="headerlink" title="PCB组织方式 — 索引方式"></a>PCB组织方式 — 索引方式</h4><p><img src="/2017/12/OS_Concept_Chapter_Three/14b20852d6668bc54dc278ba90abceca.png" alt=""></p><h4 id="PCB内容："><a href="#PCB内容：" class="headerlink" title="PCB内容："></a><strong>PCB内容：</strong></h4><p><img src="/2017/12/OS_Concept_Chapter_Three/7b7b79cd357ce5f042b474a2764fcc37.png" alt=""></p><p><strong>进程标识符、处理机状态、进程调度信息、进程控制信息</strong></p><h5 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h5><ul><li>内部标识符：<br>操作系统赋予，一个进程的序号  </li><li>外部标识符：<br>由<em>创建者提供</em>，由字母、数组组成。由<em>用户（进程）</em>在访问该进程时使用。 </li></ul><h5 id="处理机状态"><a href="#处理机状态" class="headerlink" title="处理机状态"></a>处理机状态</h5><p>寄存器中内容</p><ul><li>通用寄存器   </li><li>指令计数器：存放了要访问的下一条指令的地址  </li><li>程序状态字PSW：状态信息，（条件码、执行方式、中断屏蔽标志）  </li><li>用户栈指针：存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶</li></ul><h5 id="进程调度信息："><a href="#进程调度信息：" class="headerlink" title="进程调度信息："></a>进程调度信息：</h5><ul><li>进程状态  </li><li>优先级  </li><li>其他信息：与进程调度算法有关  </li><li>事件：进程由执行状态转变为阻塞状态所等待发生的事件、即阻塞原因</li></ul><h5 id="进程控制信息："><a href="#进程控制信息：" class="headerlink" title="进程控制信息："></a>进程控制信息：</h5><ul><li>程序和数据的地址  </li><li>进程同步和通信信息：消息队列指针、信号量等（可能全部或部分在PCB中）   </li><li>链接指针：当前进程PCB所在队列中下一个进程PCB地址</li></ul><h3 id="CPU-Switch-所谓上下文"><a href="#CPU-Switch-所谓上下文" class="headerlink" title="CPU Switch 所谓上下文"></a><em>CPU Switch</em> 所谓上下文</h3><h4 id="CPU-Switch-From-Process-to-Process"><a href="#CPU-Switch-From-Process-to-Process" class="headerlink" title="CPU Switch From Process to Process"></a>CPU Switch From Process to Process</h4><p><img src="/2017/12/OS_Concept_Chapter_Three/412a4111a85827fd346fe0c1c7534878.png" alt=""></p><h2 id="Process-Scheduling"><a href="#Process-Scheduling" class="headerlink" title="Process Scheduling"></a><strong>Process Scheduling</strong></h2><h3 id="Objective"><a href="#Objective" class="headerlink" title="Objective:"></a>Objective:</h3><ul><li><em>Maximize</em> CPU usage  </li><li><em>Quickly</em> switch processes onto CPU for time sharing   <h3 id="Process-Scheduler"><a href="#Process-Scheduler" class="headerlink" title="Process Scheduler"></a><em>Process Scheduler</em></h3></li></ul><p>Select processes for next execution on CPU</p><h3 id="Maintains-scheduling-queues-of-processes"><a href="#Maintains-scheduling-queues-of-processes" class="headerlink" title="Maintains scheduling queues of processes"></a>Maintains <em>scheduling queues</em> of processes</h3><ul><li>Job queue  </li><li>Ready queue  </li><li>Device queue</li></ul><hr><ul><li>Short-term  </li><li>Mid-term  </li><li>Long-term</li></ul><blockquote></blockquote><p><img src="/2017/12/OS_Concept_Chapter_Three/6f9dd42e36edf9e7f09d28eb59353897.png" alt=""></p><p><img src="/2017/12/OS_Concept_Chapter_Three/5e26c699832d1aa224c5560d796901ba.png" alt=""></p><p><img src="/2017/12/OS_Concept_Chapter_Three/e77123bb57ec3e6dcf86b72a59d63848.png" alt=""></p><h3 id="进程上下文："><a href="#进程上下文：" class="headerlink" title="进程上下文："></a><em>进程上下文</em>：</h3><p>进程执行活动全过程的静态描述</p><ul><li>计算机系统中执行该进程有关的<em>各种寄存器的值</em>  </li><li>程序段在经过编译之后形成的机器指令代码集（正文段）、<em>数据集</em>  </li><li>各种堆栈值  </li><li>PCB结构</li></ul><h2 id="进程操作："><a href="#进程操作：" class="headerlink" title="进程操作："></a><strong>进程操作：</strong></h2><h3 id="进程创建："><a href="#进程创建：" class="headerlink" title="进程创建："></a>进程创建：</h3><p><em>父进程</em>创建<em>子进程</em>，创建了一个进程树<br>通常来说，以进程标识符（pid）标识  </p><p>资源共享：（三种情况）   </p><ul><li>父进程子进程共享<em>所有资源</em>  </li><li>子进程分享父进程的<em>资源子集（一部分）</em>  </li><li>父进程和子进程<em>不分享资源</em>  </li></ul><p>执行（两种）</p><ul><li>父进程子进程同时执行  </li><li>父进程等待子进程结束  </li></ul><p>命名空间</p><ul><li>子复制父  </li><li>子加载了程序  </li></ul><p>UNIX例子</p><ul><li>Fork()创建  </li><li>Exec()替代fork()所创建进程（用新程序覆盖内存空间）  <h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4></li></ul><ol><li>申请空白PCB。  </li><li>为新进程分配资源。  </li><li>初始化进程控制块。  </li><li>将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li></ol><h3 id="进程结束-终止"><a href="#进程结束-终止" class="headerlink" title="进程结束/终止"></a>进程结束/终止</h3><p>Process executes last statement and asks the operating system to delete it (exit)</p><ul><li>Output data from child to parent(via wait)  </li><li>Process’ resources are deallocated by operating system  </li></ul><p>Parent may terminate execution of children processes (<em>abort</em>)</p><ul><li>Child has exceeded allocated resources  </li><li>Task assigned to child is no longer required  </li><li>If parent is exiting<blockquote><p>  Some operating systems do not allow child to continue if its parent terminates<br>  All children terminated - cascading termination(级联终止)</p></blockquote></li></ul><h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><p>Pending</p><ul><li>出现了进程挂起的事件 比如，用户进程请求将自己挂起  </li><li>或父进程请求子进程 suspend()</li></ul><p>Activation</p><ul><li>出现了进程激活的事件  </li><li>Active()</li></ul><h2 id="进程交互（通信）"><a href="#进程交互（通信）" class="headerlink" title="进程交互（通信）"></a>进程交互（通信）</h2><p>IPC</p><ul><li>Shared memory共享存储器  </li><li>Message passing消息传递  </li><li>Pipe管道</li></ul><h3 id="Shared-memory"><a href="#Shared-memory" class="headerlink" title="Shared memory"></a>Shared memory</h3><p><img src="/2017/12/OS_Concept_Chapter_Three/e095dec99b7701eac1eec5753b348d29.png" alt=""></p><h3 id="Message-passing"><a href="#Message-passing" class="headerlink" title="Message passing"></a>Message passing</h3><ul><li>消息传递机制都是用得最广泛的一种进程间通信的机制。  </li><li>在消息传递系统中，进程间的数据交换，是以格式化的消息(message)为单位的；  </li><li>程序员直接利用系统提供的一组通信命令(原语)进行通信,大大减化了通信程序编制的复杂性，而获得广泛的应用。  </li><li>消息传递系统的通信方式属于高级通信方式。  </li><li>又分为直接通信方式和间接通信方式两种。</li></ul><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。</p><p>向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；<br>而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。</p><p><em>由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信</em></p><p>首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中  </p><h3 id="Producer-Consumer-Problem写作进程的通用范例"><a href="#Producer-Consumer-Problem写作进程的通用范例" class="headerlink" title="Producer-Consumer Problem写作进程的通用范例"></a>Producer-Consumer Problem写作进程的通用范例</h3><blockquote><p>  Producer process produces information</p><p>  Consumer process consume information</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_Three/4aa856f5723b5bf568edc3a69a8a14f3.png" alt=""></p><p><img src="/2017/12/OS_Concept_Chapter_Three/d95f41d9209b25846d1974f280fd3723.png" alt=""></p><ol><li><p><strong>进程的状态有哪几种？请画出进程间基本的转换图，并说明不同状态之间怎样转换（语言描述转换图）</strong></p></li><li><p><strong>PCB的信息包括哪些，请简单说明</strong></p></li><li><p><strong>调度队列有哪几种？请简单说明。</strong></p></li><li><p><strong>进程调度有哪几种？请分别简单说明一下。</strong></p></li><li><p><strong>Process Context包括哪些信息？简单说明</strong></p></li><li><p><strong>在什么情况下需要创建进程？简单说明。</strong></p></li><li><p><strong>简述进程创建过程。</strong></p></li><li><p><strong>什么情况下需要终止进程，简单说明。</strong></p></li><li><p><strong>什么情况下进程被阻塞？什么情况下进程被唤醒？简单说明</strong></p></li><li><p><strong>进程间通信有哪几种方式？简述每一种方式。</strong></p></li></ol><p><img src="/2017/12/OS_Concept_Chapter_Three/31046a2b209f68690ab7f64bd317e4d8.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月20日&lt;br&gt;13:56&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 操作系统结构/Operating-System Structures 第二章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Two/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_Two/</id>
    <published>2017-12-12T02:11:10.000Z</published>
    <updated>2018-03-15T11:56:10.270Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月14日<br>07:34</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2il7wXwRr6ceITiFF" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2il8I5VDvOaCKgl6R" target="_blank" rel="noopener">(pdf)</a></strong></p><ol><li>services  </li><li>structuring  </li><li>installed and customized, boot  </li></ol><h2 id="Operating-system-services"><a href="#Operating-system-services" class="headerlink" title="Operating-system services"></a><strong>Operating-system services</strong></h2><h3 id="User-perspective"><a href="#User-perspective" class="headerlink" title="User perspective"></a>User perspective</h3><h4 id="UI"><a href="#UI" class="headerlink" title="UI"></a><strong>UI</strong></h4><blockquote><p>  CLI(Command-line interface)<br>  Batch<br>  GUI(Graphical user interface)   </p></blockquote><h4 id="Program-execution"><a href="#Program-execution" class="headerlink" title="Program execution"></a><strong>Program execution</strong></h4><blockquote><p>  Run, load it to the memory, end program  </p></blockquote><h4 id="I-O-operations"><a href="#I-O-operations" class="headerlink" title="I/O operations"></a><strong>I/O operations</strong></h4><blockquote><p>  File or I/O device</p></blockquote><h4 id="File-system-manipulation"><a href="#File-system-manipulation" class="headerlink" title="File-system manipulation"></a><strong>File-system manipulation</strong></h4><h4 id="Communications"><a href="#Communications" class="headerlink" title="Communications"></a><strong>Communications</strong></h4><blockquote><p>  Between process/ computers<br>  Via shared memory / through message passing</p></blockquote><h4 id="Error-detection"><a href="#Error-detection" class="headerlink" title="Error detection"></a><strong>Error detection</strong></h4><blockquote><p>  Needs to be constantly aware of possible errors<br>  Take appropriate action<br>  Debugging facilities</p></blockquote><h3 id="Resource-sharing"><a href="#Resource-sharing" class="headerlink" title="Resource sharing"></a>Resource sharing</h3><h4 id="Resource-allocation"><a href="#Resource-allocation" class="headerlink" title="Resource allocation"></a><strong>Resource allocation</strong></h4><blockquote><p>  When jobs running concurrently<br>  Special allocation code<br>  General request and release code</p></blockquote><h4 id="Accounting"><a href="#Accounting" class="headerlink" title="Accounting"></a><strong>Accounting</strong></h4><blockquote><p>  Keep track of all resources(How much &amp; What kind of)</p></blockquote><h4 id="Protection-and-security"><a href="#Protection-and-security" class="headerlink" title="Protection and security"></a><strong>Protection and security</strong></h4><blockquote><p>  Control concurrent processes</p></blockquote><h2 id="System-calls-amp-API"><a href="#System-calls-amp-API" class="headerlink" title="System calls &amp; API"></a><strong>System calls &amp; API</strong></h2><h3 id="Concept-System-call-function-call"><a href="#Concept-System-call-function-call" class="headerlink" title="Concept: System call/ function call"></a>Concept: System call/ function call</h3><p>区别<br>含义</p><blockquote><p>Shell: a set of command</p><blockquote><p>  操作系统最外面一层，管理用户与操作系统的交互<br> 等待用户输入，向操作系统解释你的输入，并处理  </p></blockquote></blockquote><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a><em>System calls</em></h3><p>Programming interface<br>Written in high-level language<br>Application Program Interface(<strong>API</strong>) rather than direct system call use</p><p>Most common API:</p><blockquote><p>  Win32<br>  POSIX<br>  JAVA</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_Two/d1cf5ae1db8157b2842f0a54ee45b524.png" alt="计算机生成了可选文字: source file destination file Cap fi19 na-rne Write érpgppttp_sqgeén, Acquirepoutputfile Write prömpt\@ screem Acce viripüt Create Outputflle i! filé exis.ts, abort Read ffom&#39;input. file Write&#39;to output,file Until&#39;: read CIO\&gt;e output file Write completion message to screen Terminate- nOrmally Figure 2.1 Example of how system calls are used. "></p><blockquote><p>  System call sequence to copy the contents of one file to another file</p></blockquote><p>As an example of a standard API, consider the ReadFile() function in the Win32 API: a function for reading from a file.<br>The API for this function appears Ln Figure 2.2.</p><p><img src="/2017/12/OS_Concept_Chapter_Two/f24ee11de0b8f0ac3d6dc8ca550f90ed.png" alt="return value BOOL ReadFiIe c function name I HANDLE LPVOID LECWORD bytes Read, LPOVERLAPPED ; Figure 2.2 The API fly the ReadFileO function. "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/dc195aa9fa86886100486684a55cf579.png" alt="open ( ) system call interface open () Implementation Of open l) systern can Figure 2.3 The handling of a user application invoking the open() system call. "></p><p>A description of the parameters passed to ReadFile() is as follows:</p><ul><li>HANDLE file—the file to be read.</li><li>LPVOID buffer—a buffer where the data will be read into and written from.</li><li>DWORD bytesToRead—the number of bytes to be read into the buffer.</li><li>LPDWORD bytesRead—the number of bytes read during the last read.</li><li>LPOVERLAPPED ovl—indicates if overlapped I/O is being used.</li></ul><blockquote><p>  Each <em>system call</em> have a number</p><blockquote><p> A table indexed according to the number</p></blockquote></blockquote><p><em>*Dual mode(See Below)</em></p><p><strong>用户程序不能直接访问系统内核模式提供的服务</strong><br><strong>系统调用就是一种特殊的接口。通过这个接口，用户可以访问内核空间</strong><br><strong>系统调用规定用户进程进入内核空间的具体位置</strong><br><strong>API就是应用程序接口，是一些预定义的函数。跟内核没有必然的联系</strong></p><p><em>两者的区别：</em></p><blockquote><p>  API是函数的定义，规定功能，和内核无直接联系<br>  系统调用通过中断<br>  API需要一个或多个系统调用<br>  API是一个提供给应用程序的接口函数，与程序员进行直接交互<br>  系统调用不与程序员进行交互，根据API函数，通过软中断向内核提交请求<br>  并不是所有API函数一一对应一个系统调用</p></blockquote><p>一个C语言的例子</p><p><img src="/2017/12/OS_Concept_Chapter_Two/d86267f9d5962fa4f6f9174ef4362d62.png" alt=""></p><h3 id="Design-and-Implementation-of-OS"><a href="#Design-and-Implementation-of-OS" class="headerlink" title="Design and Implementation of OS"></a>Design and Implementation of OS</h3><p>Important principle to separate</p><blockquote><p> Policy（策略）: What to do<br> Mechanism（机制）: How to do it</p></blockquote><h2 id="OS-Structure"><a href="#OS-Structure" class="headerlink" title="OS Structure"></a><strong>OS Structure</strong></h2><h3 id="Simple-Structure-DOS"><a href="#Simple-Structure-DOS" class="headerlink" title="Simple Structure:(DOS)"></a><em>Simple Structure:(DOS)</em></h3><h4 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h4><p>Not divided into modules<br>Most functionality in the least space<br>Interfaces and levels of functionality are not well separated</p><p><img src="/2017/12/OS_Concept_Chapter_Two/188057a49daea8846f97291dde71f597.png" alt=""></p><h3 id="Layered-Approach-UNIX"><a href="#Layered-Approach-UNIX" class="headerlink" title="Layered Approach:(UNIX)"></a><em>Layered Approach:(UNIX)</em></h3><p><img src="/2017/12/OS_Concept_Chapter_Two/aa135e39d9adaedda80ad01ee4a81972.png" alt=""></p><p>Problems:</p><blockquote><p>  Tend to be less efficient</p></blockquote><p>A layered design was first used in THE operating system. Its six layers are as follows:  </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Layer 5</td><td>user programs</td></tr><tr><td>Layer 4</td><td>buffering for input and Output</td></tr><tr><td>Layer 3</td><td>operator-console device driver</td></tr><tr><td>Layer 2</td><td>memory management</td></tr><tr><td>Layer 1</td><td>CPU sheduling</td></tr><tr><td>Layer 0</td><td>hardware</td></tr></tbody></table><h3 id="Microkernels-QNX"><a href="#Microkernels-QNX" class="headerlink" title="Microkernels:(QNX)"></a><em>Microkernels:(QNX)</em></h3><p>Move as much from the kernel into ‘user’ space<br>Communication takes place between user modules using <em>message passing</em></p><p>Benefits:</p><blockquote><p>  Easier to extend<br>  Easier to port the operating system to new architectures<br>  More reliable (less code is running in kernel mode)<br>  More secure<br>  e.g.: Mac OSX(Mach &amp; BSD -> Kernel) (<em>Hybrid Structure</em>)</p></blockquote><h3 id="Modular-Solaris"><a href="#Modular-Solaris" class="headerlink" title="Modular:(Solaris)"></a><em>Modular:(Solaris)</em></h3><p>Kernel: provide core services &amp; certain features to be implemented dynamically<br>Uses OO<br>Each core component is separate<br>Each talks to the others over known interfaces<br>Each is loadable as needed within the kernel<br>(Similar to layers but with more flexible)</p><p><img src="/2017/12/OS_Concept_Chapter_Two/960c787b18d6bf4028499dbfd89a75aa.png" alt=""></p><p>Problems:</p><blockquote><p>  Kernel security crucial</p></blockquote><h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a><strong>Virtual Machine</strong></h2><p>Take layered approach to its logical conclusion<br>Treat hardware and the operating system kernel as though they were all  hardware<br>OS host: simulation, a process has its own processor and (virtual memory)<br>The resources of the physical computer are shared to create the virtual machines</p><p><img src="/2017/12/OS_Concept_Chapter_Two/4ce414e869e32de4f4cd0998e41bf738.png" alt=""><br>Ad/Dis</p><blockquote><p>  Provides complete protection of system resources<br>  Isolated from all other virtual machines<br>  Permit no direct sharing of resources</p></blockquote><h2 id="Operating-System-Generation"><a href="#Operating-System-Generation" class="headerlink" title="Operating-System Generation"></a>Operating-System Generation</h2><p>*SYSGEN: system generation （部署）(P70)</p><h2 id="System-Boot"><a href="#System-Boot" class="headerlink" title="System Boot"></a>System Boot</h2><p>Bootstrap program<br>Bootstrap loader</p><p><img src="/2017/12/OS_Concept_Chapter_Two/804735748ffcae5e2c294f359195154d.png" alt="2.1 The services and functions provided by an operating system can be divided into two main categories. Briefly describe the two categories and discuss how they differ. "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/f946a716b0838b0dde55e3d3f69c8ef8.png" alt="22 List five services provided by an operating system that are designed to make it morc convenient fir users to use the computer system, In what cases it would be impossible user-level programs to provide these services? Explain "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/23bbfb968809287bec9f4b74a149cc9a.png" alt="2.6 2.7 What are the advantages and disadvantages Of using the same system. call interface manipulating both and devices? What is the purpose of the command interpreter? Why is it usually separate the kernel? Would it be possible the user to develop a new command interpreter using the system-call interface provided by the operating system? "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/1bedf8a660706e9982c1a853f91b28df.png" alt="C:\\A87394C5\\F2723E28-457D-482E-A856-19FAEB92EECE.files\\image012.png"></p><p><img src="/2017/12/OS_Concept_Chapter_Two/9b482d6b1722e12d5272333fdd84be35.png" alt="211 212 2.13 2.14 It is difficult to achieve a layered approach if two compentents of the operating system are dependent on each other. Identify a scenario in which it is how to layer two system components that require tight coupling of their functionalities. What is the main advantage Of the microkernel approach to System design? How do user programs and system services interact in a microkcrncl architecture? What are the disadvantages of using microkernel approach? In what ways is the modular kernel approach similar to the layered approach? In what ways does it differ from the layered approach? What is the main advantage for an operating-system designer Of using a Virtual-machine architecture? What is the main advantage a user? "></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月14日&lt;br&gt;07:34&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念 操作系统概念/Operating System Concept 第一章笔记</title>
    <link href="https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_One/"/>
    <id>https://blog.kimisecond.com/2017/12/OS_Concept_Chapter_One/</id>
    <published>2017-12-11T09:35:06.000Z</published>
    <updated>2018-03-15T11:55:35.838Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月12日<br>09:44</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2il1SdVqdwxFIroe8" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2ilzrIcP9NJnbNJbp" target="_blank" rel="noopener">(pdf)</a></strong></p><h2 id="cs-amp-os-overview"><a href="#cs-amp-os-overview" class="headerlink" title="cs &amp; os overview"></a>cs &amp; os overview</h2><p>Process management<br>Memory management<br>Storage management<br>Advanced topics<br>Lab instructions  </p><p>System thinking<br>System analysis</p><!-- more --><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a><strong>Goals</strong></h2><p><strong>Execute user programs, solve user problems easier</strong></p><p>Convenient to use<br>Use the computer hardware in an efficient manner  </p><p>‘The one program running at all times om the computer’ —-Kernel<br>Everything else are system program/ application program</p><h2 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a><strong>操作系统做什么</strong></h2><blockquote><p>  计算机系统可以大致分为<strong>4个组成部分</strong>：<strong>计算机硬件</strong>、<strong>操作系统</strong>、<strong>系统程序与应用程序</strong>、<strong>用户</strong></p></blockquote><p>（这四者严格分层叠代，并互相服务）</p><h2 id="用户视角-User’s-Perspective"><a href="#用户视角-User’s-Perspective" class="headerlink" title="用户视角/ User’s Perspective"></a><strong>用户视角/ User’s Perspective</strong></h2><h3 id="单用户（PC）"><a href="#单用户（PC）" class="headerlink" title="单用户（PC）"></a><strong>单用户</strong>（PC）</h3><p>使用方便，性能次要，不在乎资源使用率</p><h3 id="大型机与小型机相连（多用户）："><a href="#大型机与小型机相连（多用户）：" class="headerlink" title="大型机与小型机相连（多用户）："></a><strong>大型机与小型机相连（多用户）：</strong></h3><p><strong>为资源使用做优化</strong><br>确保所有的CPU时间、内存和I/O都能得到充分使用，并且确保没有用户使用超出其权限以外的资源</p><h3 id="工作站"><a href="#工作站" class="headerlink" title="工作站"></a><strong>工作站</strong></h3><p>共享资源</p><h3 id="手持计算机"><a href="#手持计算机" class="headerlink" title="手持计算机"></a><strong>手持计算机</strong></h3><p>由于CPU、内存速度有限，（电源、速度、接口限制）远程操作较少，目的是为了方便个人使用</p><h2 id="系统视角-System’s-Perspective"><a href="#系统视角-System’s-Perspective" class="headerlink" title="系统视角/ System’s Perspective"></a><strong>系统视角/ System’s Perspective</strong></h2><p>操作系统：<strong>资源分配器</strong> （Resource Allocator）</p><blockquote><p>  操作系统必须<strong>决定如何为各个程序和用户分配资源</strong>，以便计算机系统能有效而公平地运行<br>  操作系统是<strong>控制程序</strong>：<strong>管理用户程序的执行</strong>、<strong>防止计算机资源的错误使用或使用不当</strong></p></blockquote><h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><p>难以精确定义<br><em>操作系统是一直运行在计算机上的程序（通常称为内核）</em> </p><h2 id="计算机系统操作"><a href="#计算机系统操作" class="headerlink" title="计算机系统操作"></a>计算机系统操作</h2><p><strong>一个或多个CPU 设备控制器 通过共同的总线相连而成</strong><br><strong>总线提供了对共享内存的访问</strong><br><strong>CPU与设备控制器可以并发工作，并竞争内存周期</strong></p><h3 id="当打开电源或重启时，计算机开始运行"><a href="#当打开电源或重启时，计算机开始运行" class="headerlink" title="当打开电源或重启时，计算机开始运行"></a>当打开电源或重启时，计算机开始运行</h3><blockquote><p>启动<strong>引导程序</strong>（bootstrap program）<br>通常位于ROM或EEPROM中<br>计算机硬件中的<strong>固件</strong>（firmware）   </p><p><strong>首先</strong>初始化系统中的所有部分（类似自检？）<br><strong>之后</strong>引导程序必须定位操作系统内核并把它装入内存</p></blockquote><h3 id="中断（interrupt）"><a href="#中断（interrupt）" class="headerlink" title="中断（interrupt）"></a>中断（interrupt）</h3><blockquote><p>  <strong>硬件</strong>可随时通过系统总线向 CPU<br>  发出信号，以触发中断。<strong>软件</strong>通过执行特别操作如<strong>系统调用(system call)</strong><br>  <em>(也称为监视器调用 (monitor call) )</em>也能触发中断。</p></blockquote><h4 id="内部中断（trap）"><a href="#内部中断（trap）" class="headerlink" title="内部中断（trap）"></a>内部中断（<strong>trap</strong>）</h4><blockquote><p>  Hardware fault interrupt / the program interruptions / visit pipe break<br>  不可屏蔽</p></blockquote><h4 id="外部中断（event）"><a href="#外部中断（event）" class="headerlink" title="外部中断（event）"></a>外部中断（<strong>event</strong>）</h4><blockquote><p>  I/O interrupt / external interrupt<br>  可屏蔽</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/00892385560cd98391e0a5f2b9c0fc7e.png" alt="计算机生成了可选文字: 0 设 备 用 户 进 程 的 执 行 L&#39;O 中 断 的 处 理 空 闲 状 态 传 输 状 态 LO 请 求 传 输 完 成 I/O 请 求 传 输 完 成 图 单 个 进 程 执 行 输 出 的 中 断 时 间 线 路 "></p><blockquote><p>中断是计算机结构的重要部分（<strong>Interrupt-driven</strong>）<br>  <em>Software-generated interrupt: trap</em></p></blockquote><h4 id="中断向量（Interrupt-Vector）"><a href="#中断向量（Interrupt-Vector）" class="headerlink" title="中断向量（Interrupt Vector）"></a><strong>中断向量（Interrupt Vector）</strong></h4><blockquote><p>  位于低地址内存（前100左右的位置）<br>  存储各种设备的中断处理子程序的地址  </p></blockquote><p>Type of interrupt:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Polling</td><td>轮询</td></tr><tr><td>Vector interrupt system</td><td>矢量化中断系统</td></tr></tbody></table><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>内存</strong>（主存）——CPU直接访问操作<br><strong>辅存</strong>（secondary storage）——作为内存的扩充</p><blockquote><p>  对辅存的主要要求是它要能够永久地存储大量的数据<br>  最为常用的辅存设备为磁盘</p></blockquote><p>存储器性质：</p><blockquote><p>  <strong>Speed</strong><br>  <strong>Cost</strong><br>  <strong>Volatility</strong></p></blockquote><h2 id="I-O-结构"><a href="#I-O-结构" class="headerlink" title="I/O 结构"></a>I/O 结构</h2><h3 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a><strong>同步I/O</strong></h3><blockquote><p>  启动 直到 I/O完成再唤醒cpu（<strong>在此期间CPU处于等待状态</strong>）</p></blockquote><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h3><blockquote><p>  启动 进内核 完成再通知线程（<strong>在此期间CPU继续处理其他事</strong>）<br>  异步I/O在请求完成时，通过将文件句柄设为有信号状态来通知应用程序<br>  或者应用程序通过GetOverlappedResult()查看I/O请求是否完成，也可以通过一个事件对象来通知应用程序</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/c014e84ae53ab365b03e6b90305d1fd0.png" alt="kernel Synchronous requesting process waiting device driver interrupt handler hardware data transfer (a) Asynclvonous requesting process device driver interrupt handler hardware — — data transfer time (b) kernel "></p><p>传统I/O方式：以字节为单位，通知cpu</p><blockquote><p>  这种I/O中断驱动适合移动少量数据，但对大块的数据移动，比如磁盘I<br>  /O，就会带来超载问题。</p></blockquote><p>现代：<strong>DMA</strong>（direct memory access， 直接内存访问）</p><blockquote><p>  在为这种I/O设备设置好缓冲、指针和计数器之后，设备控制器能在本地缓冲和内存之间传送一整块数据，而<strong>无需</strong>CPU的干预。<strong>每块只产生一个中断。</strong></p></blockquote><p><em>由DMA控制器直接控制总线传递数据块。DMA控制器完成从I/O——内存</em></p><p><img src="/2017/12/OS_Concept_Chapter_One/1184d04f769d8a4329b0f18e35bf5a15.png" alt="C:\\657A68A5\\C869BDCE-D65F-4B51-B4F4-2653B2D1638D.files\\image003.png"></p><h2 id="系统架构："><a href="#系统架构：" class="headerlink" title="系统架构："></a><strong>系统架构</strong>：</h2><p>单处理器系统</p><p>多处理器系统（并行系统 parallel system）或（紧耦合系统 tightly coupled system）</p><p>优点：</p><blockquote><p>  1）<strong>增加吞吐量</strong> 增加处理器的数量，希望能在更短的时间内做更多的事情<br>  2）<strong>规模经济</strong> 共享外设、大容量存储和电源供给<br>  3）<strong>增加可靠性</strong> 将任务分布在多个处理器上，这样单一处理器失灵不会导致整个系统的停止</p></blockquote><p>缺点：</p><blockquote><p>  <strong>适度退化、容错</strong><br>  这些机制的实现较复杂</p></blockquote><p>非对称多处理（asymmetric multiprocessing）处理器之间：主从关系</p><blockquote><p>  <em>由主处理器控制系统，从处理器从主处理器那里寻找指令或执行预定义任务</em></p></blockquote><p><strong>对称多处理（symmetric multiprocessing，SMP）</strong>所有处理器对等</p><p><img src="/2017/12/OS_Concept_Chapter_One/2e70e2f3d588513d510b7a08899ccbdc.png" alt=""></p><p>集群系统（cluster） 由两个或多个独立的系统藕合起来</p><blockquote><p>  非对称集群：热备份模式<br>  对称集群：互相监视</p></blockquote><p>与多处理器系统的区别：</p><blockquote><p>  多处理器系统中多个cpu共享系统其它资源<br>  集群系统中每个个体都是一个<em>独立完整</em>的系统</p></blockquote><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><blockquote><p>  多道程序设计<br>  分时系统（或多任务）</p></blockquote><h2 id="操作系统操作"><a href="#操作系统操作" class="headerlink" title="操作系统操作"></a>操作系统操作</h2><p>多道程序<em>设计（系统）</em>：<br>批处理，在其他进程处理I/O时切换进程，以保持CPU繁忙</p><p><strong>分时系统</strong>（或<strong>多任务</strong>）：切换频率很高，用户可以在程序运行期间与之进行交互</p><p><strong>交互计算机系统</strong>：使用输入设备发送指令，响应通常小于1秒</p><p><strong>分时操作系统</strong>：允许许多用户同时共享计算机</p><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="*进程（process）"></a>*<strong>进程（process）</strong></h2><p>装入到内存并执行的程序</p><h3 id="陷阱（或异常）-trap-exception"><a href="#陷阱（或异常）-trap-exception" class="headerlink" title="陷阱（或异常） trap exception"></a><strong>陷阱（或异常） trap exception</strong></h3><p><strong>软件中断</strong></p><blockquote><p>   源于出错（除数为零或无效的存储访问）<br>  或源于用户程序的一个特别请求（完成操作系统服务）</p></blockquote><p><strong>双重模式</strong>操作</p><blockquote><p>  用户模式 特权模式<br>  <strong>User mode</strong> / <strong>kernel mode</strong></p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/6bc934c1546aae836f3f56e42055941e.png" alt=""></p><blockquote><p>  用 户 程 执 用 系 嘥 训 用 从 系 嘥 用 回 式 位 - l) 内 枞 式 《 模 式 位 司<br>  ） 执 行 系 训 用 用 户 模 式 到 内 核 模 式 的 转 換</p></blockquote><ol><li><p><strong>Read Chapter 1</strong></p></li><li><p><strong>CH01 Exercise</strong></p></li></ol><blockquote><p>  <strong>1.2 1.4 1.5 1.6 1.10 1.11 1.13 1.15 1.17</strong></p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/21b8bb435bd42837995cca632681e7c0.png" alt="1.2 管 理 ： 赁 利 用 问 处 在 不 同 的 作 系 统 中 以 不 同 的 形 式 出 墁 · 请 指 出 下 曲 哪 些 赁 源 必 須 被 仔 细 地 a. 主 机 系 统 或 0 型 计 算 机 通 过 服 务 器 连 接 的 T. 作 岾 “ T 持 计 算 机 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/a93d188906d674d5b9578b8626ce16bf.png" alt="1.4 在 所 列 的 两 种 设 置 中 ， 哪 些 功 能 需 要 作 系 提 供 支 持 ； 间 手 特 设 备 和 （ b ） 实 时 糸 统 · 紕 编 程 b. 虚 拟 内 存 0 分 时 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/afcf28e8bf88d8e3f28ef0c546b31da8.png" alt="1.5 捲 述 对 称 多 处 理 和 莊 对 多 处 理 的 区 别 ． 多 处 理 系 统 有 哪 蚱 优 点 和 缺 点 ？ 1.6 隻 群 系 统 与 多 处 理 器 系 有 阿 区 别 ？ 属 于 一 个 集 的 两 个 机 器 协 作 供 离 可 用 性 服 务 要 什 么 ？ "></p><p><img src="/2017/12/OS_Concept_Chapter_One/563352d1e15635c1bbe42f59bafc2c86.png" alt="凵 0 目 的 ？ 1.11 中 斷 有 作 用 ？ 陷 阱 和 中 断 有 何 区 别 ？ 用 户 程 序 能 否 有 意 地 生 成 陷 阱 ？ 如 果 是\@ 有 什 么 直 接 内 存 访 问 被 用 到 高 谏 LO 设 备 中 ， 以 0 免 日 增 加 的 CPU 行 负 祷 · CPU 接 凵 与 设 各 如 何 协 作 度 ？ &amp; CPU 伽 阿 知 内 存 燃 作 何 时 结 束 ？ 。 当 DMA 崆 器 在 度 数 时 ， 允 CPU 执 行 甚 他 程 序 · 该 进 穆 与 用 户 程 序 的 执 行 会 不 会 冲 突 ？ 如 是 ． 说 出 将 会 导 致 何 种 冲 突 · "></p><p><img src="/2017/12/OS_Concept_Chapter_One/eb771cefbcd833c951f89663a1245c2d.png" alt="有 用 的 两 个 理 由 ． 量 的 缓 存 代 替 该 设 各 呢 ？ 原 因 是 什 么 ？ 如 甾 速 存 的 專 0 可 以 做 成 和 要 0 存 的 设 备 一 样 人 （ 麵 一 个 和 磁 盘 一 样 人 的 存 ） ， 为 什 么 不 直 接 用 同 样 容 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/34f4c0326eca912fcbb401e94070dbbb.png" alt="C:\\657A68A5\\C869BDCE-D65F-4B51-B4F4-2653B2D1638D.files\\image011.png"></p><p><img src="/2017/12/OS_Concept_Chapter_One/a9d35bf94a3ae1ca5ce37d72084639c1.png" alt="1.17 列 出 下 列 类 型 作 糸 嘥 的 基 本 特 点 ． 就 世 处 理 b. 交 互 式 。 分 时 网 络 f 并 行 分 布 五 集 群 i. 手 持 "></p><p>CPU中断时，它暂停正在做的事并立即转到固定的位置去继续执行</p><p>位置：中断服务程序开始位置的地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月12日&lt;br&gt;09:44&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://blog.kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="https://blog.kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.kimisecond.com/2017/12/hello-world/"/>
    <id>https://blog.kimisecond.com/2017/12/hello-world/</id>
    <published>2017-12-07T16:40:00.000Z</published>
    <updated>2018-03-15T11:55:09.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的博客！</h2><p>本博客刚刚搭建，托管于github pages. 项目链接为：<a href="https://github.com/kimisecond/kimisecond.github.io" target="_blank" rel="noopener">https://github.com/kimisecond/kimisecond.github.io</a>.</p><p>关于本人的有关信息请参阅<a href="http://kimisecond.com/about/" target="_blank" rel="noopener">about页面</a>，谢谢！</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;欢迎来到我的博客！&quot;&gt;&lt;a href=&quot;#欢迎来到我的博客！&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的博客！&quot;&gt;&lt;/a&gt;欢迎来到我的博客！&lt;/h2&gt;&lt;p&gt;本博客刚刚搭建，托管于github pages. 项目链接为：&lt;a href=&quot;https://github.com/kimisecond/kimisecond.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kimisecond/kimisecond.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;关于本人的有关信息请参阅&lt;a href=&quot;http://kimisecond.com/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;about页面&lt;/a&gt;，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Personal" scheme="https://blog.kimisecond.com/categories/Personal/"/>
    
    
      <category term="Personal Information" scheme="https://blog.kimisecond.com/tags/Personal-Information/"/>
    
  </entry>
  
</feed>

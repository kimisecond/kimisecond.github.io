<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kimi&#39;s Blog</title>
  
  <subtitle>一个垃圾分类站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kimisecond.com/"/>
  <updated>2017-12-12T08:29:03.043Z</updated>
  <id>http://kimisecond.com/</id>
  
  <author>
    <name>Kimisecond</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统结构/Operating-System Structures 第二章笔记</title>
    <link href="http://kimisecond.com/2017/12/OS_Concept_Chapter_Two/"/>
    <id>http://kimisecond.com/2017/12/OS_Concept_Chapter_Two/</id>
    <published>2017-12-12T02:11:10.000Z</published>
    <updated>2017-12-12T08:29:03.043Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月14日<br>07:34</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2il7wXwRr6ceITiFF" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2il8I5VDvOaCKgl6R" target="_blank" rel="noopener">(pdf)</a></strong></p><ol><li>services  </li><li>structuring  </li><li>installed and customized, boot  </li></ol><h2 id="Operating-system-services"><a href="#Operating-system-services" class="headerlink" title="Operating-system services"></a><strong>Operating-system services</strong></h2><h3 id="User-perspective"><a href="#User-perspective" class="headerlink" title="User perspective"></a>User perspective</h3><h4 id="UI"><a href="#UI" class="headerlink" title="UI"></a><strong>UI</strong></h4><blockquote><p>  CLI(Command-line interface)<br>  Batch<br>  GUI(Graphical user interface)   </p></blockquote><h4 id="Program-execution"><a href="#Program-execution" class="headerlink" title="Program execution"></a><strong>Program execution</strong></h4><blockquote><p>  Run, load it to the memory, end program  </p></blockquote><h4 id="I-O-operations"><a href="#I-O-operations" class="headerlink" title="I/O operations"></a><strong>I/O operations</strong></h4><blockquote><p>  File or I/O device</p></blockquote><h4 id="File-system-manipulation"><a href="#File-system-manipulation" class="headerlink" title="File-system manipulation"></a><strong>File-system manipulation</strong></h4><h4 id="Communications"><a href="#Communications" class="headerlink" title="Communications"></a><strong>Communications</strong></h4><blockquote><p>  Between process/ computers<br>  Via shared memory / through message passing</p></blockquote><h4 id="Error-detection"><a href="#Error-detection" class="headerlink" title="Error detection"></a><strong>Error detection</strong></h4><blockquote><p>  Needs to be constantly aware of possible errors<br>  Take appropriate action<br>  Debugging facilities</p></blockquote><h3 id="Resource-sharing"><a href="#Resource-sharing" class="headerlink" title="Resource sharing"></a>Resource sharing</h3><h4 id="Resource-allocation"><a href="#Resource-allocation" class="headerlink" title="Resource allocation"></a><strong>Resource allocation</strong></h4><blockquote><p>  When jobs running concurrently<br>  Special allocation code<br>  General request and release code</p></blockquote><h4 id="Accounting"><a href="#Accounting" class="headerlink" title="Accounting"></a><strong>Accounting</strong></h4><blockquote><p>  Keep track of all resources(How much &amp; What kind of)</p></blockquote><h4 id="Protection-and-security"><a href="#Protection-and-security" class="headerlink" title="Protection and security"></a><strong>Protection and security</strong></h4><blockquote><p>  Control concurrent processes</p></blockquote><h2 id="System-calls-amp-API"><a href="#System-calls-amp-API" class="headerlink" title="System calls &amp; API"></a><strong>System calls &amp; API</strong></h2><h3 id="Concept-System-call-function-call"><a href="#Concept-System-call-function-call" class="headerlink" title="Concept: System call/ function call"></a>Concept: System call/ function call</h3><p>区别<br>含义</p><blockquote><p>Shell: a set of command</p><blockquote><p>  操作系统最外面一层，管理用户与操作系统的交互<br> 等待用户输入，向操作系统解释你的输入，并处理  </p></blockquote></blockquote><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a><em>System calls</em></h3><p>Programming interface<br>Written in high-level language<br>Application Program Interface(<strong>API</strong>) rather than direct system call use</p><p>Most common API:</p><blockquote><p>  Win32<br>  POSIX<br>  JAVA</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_Two/d1cf5ae1db8157b2842f0a54ee45b524.png" alt="计算机生成了可选文字: source file destination file Cap fi19 na-rne Write érpgppttp_sqgeén, Acquirepoutputfile Write prömpt\@ screem Acce viripüt Create Outputflle i! filé exis.ts, abort Read ffom&#39;input. file Write&#39;to output,file Until&#39;: read CIO\&gt;e output file Write completion message to screen Terminate- nOrmally Figure 2.1 Example of how system calls are used. "></p><blockquote><p>  System call sequence to copy the contents of one file to another file</p></blockquote><p>As an example of a standard API, consider the ReadFile() function in the Win32 API: a function for reading from a file.<br>The API for this function appears Ln Figure 2.2.</p><p><img src="/2017/12/OS_Concept_Chapter_Two/f24ee11de0b8f0ac3d6dc8ca550f90ed.png" alt="return value BOOL ReadFiIe c function name I HANDLE LPVOID LECWORD bytes Read, LPOVERLAPPED ; Figure 2.2 The API fly the ReadFileO function. "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/dc195aa9fa86886100486684a55cf579.png" alt="open ( ) system call interface open () Implementation Of open l) systern can Figure 2.3 The handling of a user application invoking the open() system call. "></p><p>A description of the parameters passed to ReadFile() is as follows:</p><ul><li>HANDLE file—the file to be read.</li><li>LPVOID buffer—a buffer where the data will be read into and written from.</li><li>DWORD bytesToRead—the number of bytes to be read into the buffer.</li><li>LPDWORD bytesRead—the number of bytes read during the last read.</li><li>LPOVERLAPPED ovl—indicates if overlapped I/O is being used.</li></ul><blockquote><p>  Each <em>system call</em> have a number</p><blockquote><p> A table indexed according to the number</p></blockquote></blockquote><p><em>*Dual mode(See Below)</em></p><p><strong>用户程序不能直接访问系统内核模式提供的服务</strong><br><strong>系统调用就是一种特殊的接口。通过这个接口，用户可以访问内核空间</strong><br><strong>系统调用规定用户进程进入内核空间的具体位置</strong><br><strong>API就是应用程序接口，是一些预定义的函数。跟内核没有必然的联系</strong></p><p><em>两者的区别：</em></p><blockquote><p>  API是函数的定义，规定功能，和内核无直接联系<br>  系统调用通过中断<br>  API需要一个或多个系统调用<br>  API是一个提供给应用程序的接口函数，与程序员进行直接交互<br>  系统调用不与程序员进行交互，根据API函数，通过软中断向内核提交请求<br>  并不是所有API函数一一对应一个系统调用</p></blockquote><p>一个C语言的例子</p><p><img src="/2017/12/OS_Concept_Chapter_Two/d86267f9d5962fa4f6f9174ef4362d62.png" alt=""></p><h3 id="Design-and-Implementation-of-OS"><a href="#Design-and-Implementation-of-OS" class="headerlink" title="Design and Implementation of OS"></a>Design and Implementation of OS</h3><p>Important principle to separate</p><blockquote><p> Policy（策略）: What to do<br> Mechanism（机制）: How to do it</p></blockquote><h2 id="OS-Structure"><a href="#OS-Structure" class="headerlink" title="OS Structure"></a><strong>OS Structure</strong></h2><h3 id="Simple-Structure-DOS"><a href="#Simple-Structure-DOS" class="headerlink" title="Simple Structure:(DOS)"></a><em>Simple Structure:(DOS)</em></h3><h4 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h4><p>Not divided into modules<br>Most functionality in the least space<br>Interfaces and levels of functionality are not well separated</p><p><img src="/2017/12/OS_Concept_Chapter_Two/188057a49daea8846f97291dde71f597.png" alt=""></p><h3 id="Layered-Approach-UNIX"><a href="#Layered-Approach-UNIX" class="headerlink" title="Layered Approach:(UNIX)"></a><em>Layered Approach:(UNIX)</em></h3><p><img src="/2017/12/OS_Concept_Chapter_Two/aa135e39d9adaedda80ad01ee4a81972.png" alt=""></p><p>Problems:</p><blockquote><p>  Tend to be less efficient</p></blockquote><p>A layered design was first used in THE operating system. Its six layers are as follows:  </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Layer 5</td><td>user programs</td></tr><tr><td>Layer 4</td><td>buffering for input and Output</td></tr><tr><td>Layer 3</td><td>operator-console device driver</td></tr><tr><td>Layer 2</td><td>memory management</td></tr><tr><td>Layer 1</td><td>CPU sheduling</td></tr><tr><td>Layer 0</td><td>hardware</td></tr></tbody></table><h3 id="Microkernels-QNX"><a href="#Microkernels-QNX" class="headerlink" title="Microkernels:(QNX)"></a><em>Microkernels:(QNX)</em></h3><p>Move as much from the kernel into ‘user’ space<br>Communication takes place between user modules using <em>message passing</em></p><p>Benefits:</p><blockquote><p>  Easier to extend<br>  Easier to port the operating system to new architectures<br>  More reliable (less code is running in kernel mode)<br>  More secure<br>  e.g.: Mac OSX(Mach &amp; BSD -> Kernel) (<em>Hybrid Structure</em>)</p></blockquote><h3 id="Modular-Solaris"><a href="#Modular-Solaris" class="headerlink" title="Modular:(Solaris)"></a><em>Modular:(Solaris)</em></h3><p>Kernel: provide core services &amp; certain features to be implemented dynamically<br>Uses OO<br>Each core component is separate<br>Each talks to the others over known interfaces<br>Each is loadable as needed within the kernel<br>(Similar to layers but with more flexible)</p><p><img src="/2017/12/OS_Concept_Chapter_Two/960c787b18d6bf4028499dbfd89a75aa.png" alt=""></p><p>Problems:</p><blockquote><p>  Kernel security crucial</p></blockquote><h2 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a><strong>Virtual Machine</strong></h2><p>Take layered approach to its logical conclusion<br>Treat hardware and the operating system kernel as though they were all  hardware<br>OS host: simulation, a process has its own processor and (virtual memory)<br>The resources of the physical computer are shared to create the virtual machines</p><p><img src="/2017/12/OS_Concept_Chapter_Two/4ce414e869e32de4f4cd0998e41bf738.png" alt=""><br>Ad/Dis</p><blockquote><p>  Provides complete protection of system resources<br>  Isolated from all other virtual machines<br>  Permit no direct sharing of resources</p></blockquote><h2 id="Operating-System-Generation"><a href="#Operating-System-Generation" class="headerlink" title="Operating-System Generation"></a>Operating-System Generation</h2><p>*SYSGEN: system generation （部署）(P70)</p><h2 id="System-Boot"><a href="#System-Boot" class="headerlink" title="System Boot"></a>System Boot</h2><p>Bootstrap program<br>Bootstrap loader</p><p><img src="/2017/12/OS_Concept_Chapter_Two/804735748ffcae5e2c294f359195154d.png" alt="2.1 The services and functions provided by an operating system can be divided into two main categories. Briefly describe the two categories and discuss how they differ. "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/f946a716b0838b0dde55e3d3f69c8ef8.png" alt="22 List five services provided by an operating system that are designed to make it morc convenient fir users to use the computer system, In what cases it would be impossible user-level programs to provide these services? Explain "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/23bbfb968809287bec9f4b74a149cc9a.png" alt="2.6 2.7 What are the advantages and disadvantages Of using the same system. call interface manipulating both and devices? What is the purpose of the command interpreter? Why is it usually separate the kernel? Would it be possible the user to develop a new command interpreter using the system-call interface provided by the operating system? "></p><p><img src="/2017/12/OS_Concept_Chapter_Two/1bedf8a660706e9982c1a853f91b28df.png" alt="C:\\A87394C5\\F2723E28-457D-482E-A856-19FAEB92EECE.files\\image012.png"></p><p><img src="/2017/12/OS_Concept_Chapter_Two/9b482d6b1722e12d5272333fdd84be35.png" alt="211 212 2.13 2.14 It is difficult to achieve a layered approach if two compentents of the operating system are dependent on each other. Identify a scenario in which it is how to layer two system components that require tight coupling of their functionalities. What is the main advantage Of the microkernel approach to System design? How do user programs and system services interact in a microkcrncl architecture? What are the disadvantages of using microkernel approach? In what ways is the modular kernel approach similar to the layered approach? In what ways does it differ from the layered approach? What is the main advantage for an operating-system designer Of using a Virtual-machine architecture? What is the main advantage a user? "></p><hr><h1 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h1><p>本文标题：操作系统结构/Operating-System Structures 第二章笔记<br>本文链接：<a href="http://kimisecond.com/2017/12/OS_Concept_Chapter_Two/">http://kimisecond.com/2017/12/OS_Concept_Chapter_Two/</a><br>作者：<a href="http://kimisecond.com/">Kimisecond</a><br>出处：<a href="http://kimisecond.com/2017/12/OS_Concept_Chapter_Two/">Kimi’s Blog</a><br>发布时间：2017年12月11日<br>最后更新：2017年12月11日  </p><p><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></p><p>本文基于<strong><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a></strong> <strong>署名-非商业性使用-相同方式共享 4.0 国际许可协议</strong>发布，欢迎转载，但是<strong>必须保留</strong>本文的署名<a href="https://kimisecond.com/">Kimisecond</a>及链接: <a href="https://kimisecond.com/">https://kimisecond.com/</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月14日&lt;br&gt;07:34&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="http://kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念/Operating System Concept 第一章笔记</title>
    <link href="http://kimisecond.com/2017/12/OS_Concept_Chapter_One/"/>
    <id>http://kimisecond.com/2017/12/OS_Concept_Chapter_One/</id>
    <published>2017-12-11T09:35:06.000Z</published>
    <updated>2017-12-12T08:01:51.019Z</updated>
    
    <content type="html"><![CDATA[<p>2017年9月12日<br>09:44</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。</p><p>如有错误，请在评论中或直接联系我指正，谢谢！</p><a id="more"></a><p><strong>原始文件下载：<a href="https://1drv.ms/u/s!AkFCnbJhobZ2il1SdVqdwxFIroe8" target="_blank" rel="noopener">(mht)</a><a href="https://1drv.ms/b/s!AkFCnbJhobZ2ilzrIcP9NJnbNJbp" target="_blank" rel="noopener">(pdf)</a></strong></p><h2 id="cs-amp-os-overview"><a href="#cs-amp-os-overview" class="headerlink" title="cs &amp; os overview"></a>cs &amp; os overview</h2><p>Process management<br>Memory management<br>Storage management<br>Advanced topics<br>Lab instructions  </p><p>System thinking<br>System analysis</p><!-- more --><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a><strong>Goals</strong></h2><p><strong>Execute user programs, solve user problems easier</strong></p><p>Convenient to use<br>Use the computer hardware in an efficient manner  </p><p>‘The one program running at all times om the computer’ —-Kernel<br>Everything else are system program/ application program</p><h2 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a><strong>操作系统做什么</strong></h2><blockquote><p>  计算机系统可以大致分为<strong>4个组成部分</strong>：<strong>计算机硬件</strong>、<strong>操作系统</strong>、<strong>系统程序与应用程序</strong>、<strong>用户</strong></p></blockquote><p>（这四者严格分层叠代，并互相服务）</p><h2 id="用户视角-User’s-Perspective"><a href="#用户视角-User’s-Perspective" class="headerlink" title="用户视角/ User’s Perspective"></a><strong>用户视角/ User’s Perspective</strong></h2><h3 id="单用户（PC）"><a href="#单用户（PC）" class="headerlink" title="单用户（PC）"></a><strong>单用户</strong>（PC）</h3><p>使用方便，性能次要，不在乎资源使用率</p><h3 id="大型机与小型机相连（多用户）："><a href="#大型机与小型机相连（多用户）：" class="headerlink" title="大型机与小型机相连（多用户）："></a><strong>大型机与小型机相连（多用户）：</strong></h3><p><strong>为资源使用做优化</strong><br>确保所有的CPU时间、内存和I/O都能得到充分使用，并且确保没有用户使用超出其权限以外的资源</p><h3 id="工作站"><a href="#工作站" class="headerlink" title="工作站"></a><strong>工作站</strong></h3><p>共享资源</p><h3 id="手持计算机"><a href="#手持计算机" class="headerlink" title="手持计算机"></a><strong>手持计算机</strong></h3><p>由于CPU、内存速度有限，（电源、速度、接口限制）远程操作较少，目的是为了方便个人使用</p><h2 id="系统视角-System’s-Perspective"><a href="#系统视角-System’s-Perspective" class="headerlink" title="系统视角/ System’s Perspective"></a><strong>系统视角/ System’s Perspective</strong></h2><p>操作系统：<strong>资源分配器</strong> （Resource Allocator）</p><blockquote><p>  操作系统必须<strong>决定如何为各个程序和用户分配资源</strong>，以便计算机系统能有效而公平地运行<br>  操作系统是<strong>控制程序</strong>：<strong>管理用户程序的执行</strong>、<strong>防止计算机资源的错误使用或使用不当</strong></p></blockquote><h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><p>难以精确定义<br><em>操作系统是一直运行在计算机上的程序（通常称为内核）</em> </p><h2 id="计算机系统操作"><a href="#计算机系统操作" class="headerlink" title="计算机系统操作"></a>计算机系统操作</h2><p><strong>一个或多个CPU 设备控制器 通过共同的总线相连而成</strong><br><strong>总线提供了对共享内存的访问</strong><br><strong>CPU与设备控制器可以并发工作，并竞争内存周期</strong></p><h3 id="当打开电源或重启时，计算机开始运行"><a href="#当打开电源或重启时，计算机开始运行" class="headerlink" title="当打开电源或重启时，计算机开始运行"></a>当打开电源或重启时，计算机开始运行</h3><blockquote><p>启动<strong>引导程序</strong>（bootstrap program）<br>通常位于ROM或EEPROM中<br>计算机硬件中的<strong>固件</strong>（firmware）   </p><p><strong>首先</strong>初始化系统中的所有部分（类似自检？）<br><strong>之后</strong>引导程序必须定位操作系统内核并把它装入内存</p></blockquote><h3 id="中断（interrupt）"><a href="#中断（interrupt）" class="headerlink" title="中断（interrupt）"></a>中断（interrupt）</h3><blockquote><p>  <strong>硬件</strong>可随时通过系统总线向 CPU<br>  发出信号，以触发中断。<strong>软件</strong>通过执行特别操作如<strong>系统调用(system call)</strong><br>  <em>(也称为监视器调用 (monitor call) )</em>也能触发中断。</p></blockquote><h4 id="内部中断（trap）"><a href="#内部中断（trap）" class="headerlink" title="内部中断（trap）"></a>内部中断（<strong>trap</strong>）</h4><blockquote><p>  Hardware fault interrupt / the program interruptions / visit pipe break<br>  不可屏蔽</p></blockquote><h4 id="外部中断（event）"><a href="#外部中断（event）" class="headerlink" title="外部中断（event）"></a>外部中断（<strong>event</strong>）</h4><blockquote><p>  I/O interrupt / external interrupt<br>  可屏蔽</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/00892385560cd98391e0a5f2b9c0fc7e.png" alt="计算机生成了可选文字: 0 设 备 用 户 进 程 的 执 行 L&#39;O 中 断 的 处 理 空 闲 状 态 传 输 状 态 LO 请 求 传 输 完 成 I/O 请 求 传 输 完 成 图 单 个 进 程 执 行 输 出 的 中 断 时 间 线 路 "></p><blockquote><p>中断是计算机结构的重要部分（<strong>Interrupt-driven</strong>）<br>  <em>Software-generated interrupt: trap</em></p></blockquote><h4 id="中断向量（Interrupt-Vector）"><a href="#中断向量（Interrupt-Vector）" class="headerlink" title="中断向量（Interrupt Vector）"></a><strong>中断向量（Interrupt Vector）</strong></h4><blockquote><p>  位于低地址内存（前100左右的位置）<br>  存储各种设备的中断处理子程序的地址  </p></blockquote><p>Type of interrupt:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Polling</td><td>轮询</td></tr><tr><td>Vector interrupt system</td><td>矢量化中断系统</td></tr></tbody></table><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>内存</strong>（主存）——CPU直接访问操作<br><strong>辅存</strong>（secondary storage）——作为内存的扩充</p><blockquote><p>  对辅存的主要要求是它要能够永久地存储大量的数据<br>  最为常用的辅存设备为磁盘</p></blockquote><p>存储器性质：</p><blockquote><p>  <strong>Speed</strong><br>  <strong>Cost</strong><br>  <strong>Volatility</strong></p></blockquote><h2 id="I-O-结构"><a href="#I-O-结构" class="headerlink" title="I/O 结构"></a>I/O 结构</h2><h3 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a><strong>同步I/O</strong></h3><blockquote><p>  启动 直到 I/O完成再唤醒cpu（<strong>在此期间CPU处于等待状态</strong>）</p></blockquote><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h3><blockquote><p>  启动 进内核 完成再通知线程（<strong>在此期间CPU继续处理其他事</strong>）<br>  异步I/O在请求完成时，通过将文件句柄设为有信号状态来通知应用程序<br>  或者应用程序通过GetOverlappedResult()查看I/O请求是否完成，也可以通过一个事件对象来通知应用程序</p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/c014e84ae53ab365b03e6b90305d1fd0.png" alt="kernel Synchronous requesting process waiting device driver interrupt handler hardware data transfer (a) Asynclvonous requesting process device driver interrupt handler hardware — — data transfer time (b) kernel "></p><p>传统I/O方式：以字节为单位，通知cpu</p><blockquote><p>  这种I/O中断驱动适合移动少量数据，但对大块的数据移动，比如磁盘I<br>  /O，就会带来超载问题。</p></blockquote><p>现代：<strong>DMA</strong>（direct memory access， 直接内存访问）</p><blockquote><p>  在为这种I/O设备设置好缓冲、指针和计数器之后，设备控制器能在本地缓冲和内存之间传送一整块数据，而<strong>无需</strong>CPU的干预。<strong>每块只产生一个中断。</strong></p></blockquote><p><em>由DMA控制器直接控制总线传递数据块。DMA控制器完成从I/O——内存</em></p><p><img src="/2017/12/OS_Concept_Chapter_One/1184d04f769d8a4329b0f18e35bf5a15.png" alt="C:\\657A68A5\\C869BDCE-D65F-4B51-B4F4-2653B2D1638D.files\\image003.png"></p><h2 id="系统架构："><a href="#系统架构：" class="headerlink" title="系统架构："></a><strong>系统架构</strong>：</h2><p>单处理器系统</p><p>多处理器系统（并行系统 parallel system）或（紧耦合系统 tightly coupled system）</p><p>优点：</p><blockquote><p>  1）<strong>增加吞吐量</strong> 增加处理器的数量，希望能在更短的时间内做更多的事情<br>  2）<strong>规模经济</strong> 共享外设、大容量存储和电源供给<br>  3）<strong>增加可靠性</strong> 将任务分布在多个处理器上，这样单一处理器失灵不会导致整个系统的停止</p></blockquote><p>缺点：</p><blockquote><p>  <strong>适度退化、容错</strong><br>  这些机制的实现较复杂</p></blockquote><p>非对称多处理（asymmetric multiprocessing）处理器之间：主从关系</p><blockquote><p>  <em>由主处理器控制系统，从处理器从主处理器那里寻找指令或执行预定义任务</em></p></blockquote><p><strong>对称多处理（symmetric multiprocessing，SMP）</strong>所有处理器对等</p><p><img src="/2017/12/OS_Concept_Chapter_One/2e70e2f3d588513d510b7a08899ccbdc.png" alt=""></p><p>集群系统（cluster） 由两个或多个独立的系统藕合起来</p><blockquote><p>  非对称集群：热备份模式<br>  对称集群：互相监视</p></blockquote><p>与多处理器系统的区别：</p><blockquote><p>  多处理器系统中多个cpu共享系统其它资源<br>  集群系统中每个个体都是一个<em>独立完整</em>的系统</p></blockquote><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><blockquote><p>  多道程序设计<br>  分时系统（或多任务）</p></blockquote><h2 id="操作系统操作"><a href="#操作系统操作" class="headerlink" title="操作系统操作"></a>操作系统操作</h2><p>多道程序<em>设计（系统）</em>：<br>批处理，在其他进程处理I/O时切换进程，以保持CPU繁忙</p><p><strong>分时系统</strong>（或<strong>多任务</strong>）：切换频率很高，用户可以在程序运行期间与之进行交互</p><p><strong>交互计算机系统</strong>：使用输入设备发送指令，响应通常小于1秒</p><p><strong>分时操作系统</strong>：允许许多用户同时共享计算机</p><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="*进程（process）"></a>*<strong>进程（process）</strong></h2><p>装入到内存并执行的程序</p><h3 id="陷阱（或异常）-trap-exception"><a href="#陷阱（或异常）-trap-exception" class="headerlink" title="陷阱（或异常） trap exception"></a><strong>陷阱（或异常） trap exception</strong></h3><p><strong>软件中断</strong></p><blockquote><p>   源于出错（除数为零或无效的存储访问）<br>  或源于用户程序的一个特别请求（完成操作系统服务）</p></blockquote><p><strong>双重模式</strong>操作</p><blockquote><p>  用户模式 特权模式<br>  <strong>User mode</strong> / <strong>kernel mode</strong></p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/6bc934c1546aae836f3f56e42055941e.png" alt=""></p><blockquote><p>  用 户 程 执 用 系 嘥 训 用 从 系 嘥 用 回 式 位 - l) 内 枞 式 《 模 式 位 司<br>  ） 执 行 系 训 用 用 户 模 式 到 内 核 模 式 的 转 換</p></blockquote><ol><li><p><strong>Read Chapter 1</strong></p></li><li><p><strong>CH01 Exercise</strong></p></li></ol><blockquote><p>  <strong>1.2 1.4 1.5 1.6 1.10 1.11 1.13 1.15 1.17</strong></p></blockquote><p><img src="/2017/12/OS_Concept_Chapter_One/21b8bb435bd42837995cca632681e7c0.png" alt="1.2 管 理 ： 赁 利 用 问 处 在 不 同 的 作 系 统 中 以 不 同 的 形 式 出 墁 · 请 指 出 下 曲 哪 些 赁 源 必 須 被 仔 细 地 a. 主 机 系 统 或 0 型 计 算 机 通 过 服 务 器 连 接 的 T. 作 岾 “ T 持 计 算 机 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/a93d188906d674d5b9578b8626ce16bf.png" alt="1.4 在 所 列 的 两 种 设 置 中 ， 哪 些 功 能 需 要 作 系 提 供 支 持 ； 间 手 特 设 备 和 （ b ） 实 时 糸 统 · 紕 编 程 b. 虚 拟 内 存 0 分 时 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/afcf28e8bf88d8e3f28ef0c546b31da8.png" alt="1.5 捲 述 对 称 多 处 理 和 莊 对 多 处 理 的 区 别 ． 多 处 理 系 统 有 哪 蚱 优 点 和 缺 点 ？ 1.6 隻 群 系 统 与 多 处 理 器 系 有 阿 区 别 ？ 属 于 一 个 集 的 两 个 机 器 协 作 供 离 可 用 性 服 务 要 什 么 ？ "></p><p><img src="/2017/12/OS_Concept_Chapter_One/563352d1e15635c1bbe42f59bafc2c86.png" alt="凵 0 目 的 ？ 1.11 中 斷 有 作 用 ？ 陷 阱 和 中 断 有 何 区 别 ？ 用 户 程 序 能 否 有 意 地 生 成 陷 阱 ？ 如 果 是\@ 有 什 么 直 接 内 存 访 问 被 用 到 高 谏 LO 设 备 中 ， 以 0 免 日 增 加 的 CPU 行 负 祷 · CPU 接 凵 与 设 各 如 何 协 作 度 ？ &amp; CPU 伽 阿 知 内 存 燃 作 何 时 结 束 ？ 。 当 DMA 崆 器 在 度 数 时 ， 允 CPU 执 行 甚 他 程 序 · 该 进 穆 与 用 户 程 序 的 执 行 会 不 会 冲 突 ？ 如 是 ． 说 出 将 会 导 致 何 种 冲 突 · "></p><p><img src="/2017/12/OS_Concept_Chapter_One/eb771cefbcd833c951f89663a1245c2d.png" alt="有 用 的 两 个 理 由 ． 量 的 缓 存 代 替 该 设 各 呢 ？ 原 因 是 什 么 ？ 如 甾 速 存 的 專 0 可 以 做 成 和 要 0 存 的 设 备 一 样 人 （ 麵 一 个 和 磁 盘 一 样 人 的 存 ） ， 为 什 么 不 直 接 用 同 样 容 "></p><p><img src="/2017/12/OS_Concept_Chapter_One/34f4c0326eca912fcbb401e94070dbbb.png" alt="C:\\657A68A5\\C869BDCE-D65F-4B51-B4F4-2653B2D1638D.files\\image011.png"></p><p><img src="/2017/12/OS_Concept_Chapter_One/a9d35bf94a3ae1ca5ce37d72084639c1.png" alt="1.17 列 出 下 列 类 型 作 糸 嘥 的 基 本 特 点 ． 就 世 处 理 b. 交 互 式 。 分 时 网 络 f 并 行 分 布 五 集 群 i. 手 持 "></p><p>CPU中断时，它暂停正在做的事并立即转到固定的位置去继续执行</p><p>位置：中断服务程序开始位置的地址</p><hr><h1 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h1><p>本文标题：操作系统概念/Operating System Concept 第一章笔记<br>本文链接：<a href="http://kimisecond.com/2017/12/OS_Concept_Chapter_One/">http://kimisecond.com/2017/12/OS_Concept_Chapter_One/</a><br>作者：<a href="http://kimisecond.com/">Kimisecond</a><br>出处：<a href="http://kimisecond.com/2017/12/OS_Concept_Chapter_One/">Kimi’s Blog</a><br>发布时间：2017年12月11日<br>最后更新：2017年12月11日  </p><p><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></p><p>本文基于<strong><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a></strong> <strong>署名-非商业性使用-相同方式共享 4.0 国际许可协议</strong>发布，欢迎转载，但是<strong>必须保留</strong>本文的署名<a href="https://kimisecond.com/">Kimisecond</a>及链接: <a href="https://kimisecond.com/">https://kimisecond.com/</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年9月12日&lt;br&gt;09:44&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本笔记仅仅是本人在上课时的一些随手记录，并不完整也不完全正确。&lt;/p&gt;
&lt;p&gt;如有错误，请在评论中或直接联系我指正，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://kimisecond.com/categories/Notes/"/>
    
    
      <category term="OS_Concept" scheme="http://kimisecond.com/tags/OS-Concept/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://kimisecond.com/2017/12/hello-world/"/>
    <id>http://kimisecond.com/2017/12/hello-world/</id>
    <published>2017-12-07T16:40:00.000Z</published>
    <updated>2017-12-11T13:24:44.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的博客！"><a href="#欢迎来到我的博客！" class="headerlink" title="欢迎来到我的博客！"></a>欢迎来到我的博客！</h2><p>本博客刚刚搭建，托管于github pages. 项目链接为：<a href="https://github.com/kimisecond/kimisecond.github.io" target="_blank" rel="noopener">https://github.com/kimisecond/kimisecond.github.io</a>.</p><p>关于本人的有关信息请参阅<a href="http://kimisecond.com/about/">about页面</a>，谢谢！</p><a id="more"></a><hr><h1 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h1><p>本文标题：Hello World<br>本文链接：<a href="http://kimisecond.com/2017/12/hello-world/">http://kimisecond.com/2017/12/hello-world/</a><br>作者：<a href="http://kimisecond.com/">Kimisecond</a><br>出处：<a href="http://kimisecond.com/2017/12/hello-world/">Kimi’s Blog</a><br>发布时间：2017年12月08日<br>最后更新：2017年12月11日  </p><p><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></p><p>本文基于<strong><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a></strong> <strong>署名-非商业性使用-相同方式共享 4.0 国际许可协议</strong>发布，欢迎转载，但是<strong>必须保留</strong>本文的署名<a href="https://kimisecond.com/">Kimisecond</a>及链接: <a href="https://kimisecond.com/">https://kimisecond.com/</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;欢迎来到我的博客！&quot;&gt;&lt;a href=&quot;#欢迎来到我的博客！&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的博客！&quot;&gt;&lt;/a&gt;欢迎来到我的博客！&lt;/h2&gt;&lt;p&gt;本博客刚刚搭建，托管于github pages. 项目链接为：&lt;a href=&quot;https://github.com/kimisecond/kimisecond.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kimisecond/kimisecond.github.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;关于本人的有关信息请参阅&lt;a href=&quot;http://kimisecond.com/about/&quot;&gt;about页面&lt;/a&gt;，谢谢！&lt;/p&gt;
    
    </summary>
    
      <category term="Personal" scheme="http://kimisecond.com/categories/Personal/"/>
    
    
      <category term="Personal Information" scheme="http://kimisecond.com/tags/Personal-Information/"/>
    
  </entry>
  
</feed>
